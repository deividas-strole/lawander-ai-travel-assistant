{"ast":null,"code":"// Remove leading markdown-like tokens from popup text only (e.g. ###, -, *, bullets)\nexport const sanitizeLeading = s => {\n  if (!s && s !== \"\") return s;\n  const str = String(s);\n  return str.replace(/^\\s*(?:[#\\-\\*\\u2022]+[\\s:]*)+/, \"\").trim();\n};\nexport const extractPlaceNames = text => {\n  console.log(\"Extracting place names from text:\", text);\n  const regex = /\\*\\*(.*?)\\*\\*/g;\n  const matches = [];\n  let match;\n  while ((match = regex.exec(text)) !== null) {\n    matches.push(match[1].trim());\n  }\n  console.log(\"Found matches:\", matches);\n  return matches;\n};\nexport const extractPlaceDescriptions = (text, placeNames) => {\n  const descriptions = {};\n  const textForDescriptions = String(text).replace(/^[ \\t]*[-*•]?\\s*#*\\s*day\\s*\\d+(?::|-)?\\s*.*$/gim, \"\\n\");\n  const sentences = textForDescriptions.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);\n  placeNames.forEach(placeName => {\n    const relevantSentences = sentences.filter(sentence => sentence.toLowerCase().includes(placeName.toLowerCase()));\n    if (relevantSentences.length > 0) {\n      let description = relevantSentences[0];\n      description = description.replace(new RegExp(`\\\\*\\\\*${placeName}\\\\*\\\\*`, \"gi\"), \"\").trim();\n      description = description.replace(/:/g, \"\");\n      description = description.replace(/^(is|are|was|were|has|have|had|will|would|can|could|should|may|might)\\s+/i, \"\");\n      description = description.charAt(0).toUpperCase() + description.slice(1);\n      description = sanitizeLeading(description);\n      descriptions[placeName] = description;\n    }\n  });\n  console.log(\"Extracted place descriptions:\", descriptions);\n  return descriptions;\n};\nexport const formatMessageText = (text, foundPlaces = []) => {\n  if (foundPlaces.length === 0) {\n    return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\");\n  }\n  const foundLower = foundPlaces.map(p => p.toLowerCase());\n  return text.replace(/\\*\\*(.*?)\\*\\*/g, (match, placeName) => {\n    const trimmedPlaceName = placeName.trim();\n    if (foundLower.includes(trimmedPlaceName.toLowerCase())) {\n      return `<span class=\"place-name clickable-place\" data-place=\"${trimmedPlaceName}\">${placeName}</span>`;\n    } else {\n      return placeName;\n    }\n  });\n};\nexport const formatItineraryToHtml = (rawText, foundPlaces = []) => {\n  if (!rawText) return \"\";\n  const normalized = rawText.replace(/\\r\\n/g, \"\\n\");\n  const lines = normalized.split(\"\\n\").map(l => l.replace(/^\\s*###\\s*/i, \"\").trim());\n  const daySections = [];\n  let current = null;\n  const dayHeaderRegex = /^#*\\s*day\\s*(\\d+)(?::|-)?\\s*(.*)$/i;\n  const pushCurrent = () => {\n    if (current) {\n      current.items = current.items.filter(i => i.trim().length > 0);\n      daySections.push(current);\n      current = null;\n    }\n  };\n  const foundLower = foundPlaces.map(p => p.toLowerCase());\n  const foundMap = {};\n  foundPlaces.forEach(p => foundMap[p.toLowerCase()] = p);\n  for (let rawLine of lines) {\n    if (!rawLine) continue;\n    let line = rawLine.replace(/^[-*•]\\s*/, \"\").trim();\n    if (!line) continue;\n    const m = line.match(dayHeaderRegex);\n    if (m) {\n      pushCurrent();\n      const dayNum = m[1];\n      const rest = (m[2] || \"\").trim();\n      current = {\n        title: `Day ${dayNum}${rest ? `: ${rest}` : \"\"}`,\n        items: []\n      };\n      continue;\n    }\n    if (!current) continue;\n    let cleaned = line.replace(/^[-*•]\\s*/, \"\");\n    const dashIdx = cleaned.indexOf(\" - \");\n    let itemHtml = cleaned;\n    const wrapPlace = placeLabel => {\n      const original = foundMap[placeLabel.toLowerCase()] || placeLabel;\n      return `<span class=\\\"place-name clickable-place blue-place\\\" data-place=\\\"${original}\\\">${original}</span>`;\n    };\n    if (dashIdx > 0) {\n      let left = cleaned.substring(0, dashIdx).trim();\n      let rest = cleaned.substring(dashIdx + 3);\n      left = left.replace(/^[0-9]+\\.\\s*/, \"\").replace(/^[-*•]\\s*/, \"\");\n      const leftUnmarked = left.replace(/^\\*\\*(.*)\\*\\*$/, \"$1\").trim();\n      let matched = null;\n      if (foundLower.includes(leftUnmarked.toLowerCase())) {\n        matched = foundMap[leftUnmarked.toLowerCase()];\n      } else {\n        for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\n          if (leftUnmarked.toLowerCase().includes(p.toLowerCase())) {\n            matched = p;\n            break;\n          }\n        }\n      }\n      if (matched) {\n        const wrapped = wrapPlace(matched);\n        itemHtml = `${wrapped} - ${rest}`;\n      } else {\n        itemHtml = `${left} - ${rest}`;\n      }\n    } else {\n      const prefix = cleaned.substring(0, 60);\n      let matched = null;\n      for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\n        if (prefix.toLowerCase().includes(p.toLowerCase())) {\n          matched = p;\n          break;\n        }\n      }\n      if (matched) {\n        const wrapped = wrapPlace(matched);\n        itemHtml = cleaned.replace(new RegExp(matched.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), wrapped);\n      }\n    }\n    current.items.push(itemHtml);\n  }\n  pushCurrent();\n  if (daySections.length === 0) {\n    return normalized.split(\"\\n\").filter(l => l.trim().length > 0).map(l => l.replace(/^\\s*###\\s*/i, \"\")).join(\"<br/>\");\n  }\n  const html = daySections.map(d => {\n    const itemsHtml = d.items.join(\"<br/>\");\n    return `<p style=\\\"margin: 0 0 14px 0;\\\"><strong>${d.title}</strong><br/>${itemsHtml}</p>`;\n  }).join(\"\\n\");\n  return html;\n};","map":{"version":3,"names":["sanitizeLeading","s","str","String","replace","trim","extractPlaceNames","text","console","log","regex","matches","match","exec","push","extractPlaceDescriptions","placeNames","descriptions","textForDescriptions","sentences","split","map","filter","length","forEach","placeName","relevantSentences","sentence","toLowerCase","includes","description","RegExp","charAt","toUpperCase","slice","formatMessageText","foundPlaces","foundLower","p","trimmedPlaceName","formatItineraryToHtml","rawText","normalized","lines","l","daySections","current","dayHeaderRegex","pushCurrent","items","i","foundMap","rawLine","line","m","dayNum","rest","title","cleaned","dashIdx","indexOf","itemHtml","wrapPlace","placeLabel","original","left","substring","leftUnmarked","matched","sort","a","b","wrapped","prefix","join","html","d","itemsHtml"],"sources":["C:/Users/Deividas/aaaaaMyProjects/LaWander/Front/src/utils/textProcessing.js"],"sourcesContent":["// Remove leading markdown-like tokens from popup text only (e.g. ###, -, *, bullets)\r\nexport const sanitizeLeading = (s) => {\r\n  if (!s && s !== \"\") return s;\r\n  const str = String(s);\r\n  return str.replace(/^\\s*(?:[#\\-\\*\\u2022]+[\\s:]*)+/, \"\").trim();\r\n};\r\n\r\nexport const extractPlaceNames = (text) => {\r\n  console.log(\"Extracting place names from text:\", text);\r\n  const regex = /\\*\\*(.*?)\\*\\*/g;\r\n  const matches = [];\r\n  let match;\r\n  while ((match = regex.exec(text)) !== null) {\r\n    matches.push(match[1].trim());\r\n  }\r\n  console.log(\"Found matches:\", matches);\r\n  return matches;\r\n};\r\n\r\nexport const extractPlaceDescriptions = (text, placeNames) => {\r\n  const descriptions = {};\r\n\r\n  const textForDescriptions = String(text).replace(/^[ \\t]*[-*•]?\\s*#*\\s*day\\s*\\d+(?::|-)?\\s*.*$/gim, \"\\n\");\r\n\r\n  const sentences = textForDescriptions\r\n    .split(/[.!?]+/)\r\n    .map((s) => s.trim())\r\n    .filter((s) => s.length > 0);\r\n\r\n  placeNames.forEach((placeName) => {\r\n    const relevantSentences = sentences.filter((sentence) =>\r\n      sentence.toLowerCase().includes(placeName.toLowerCase())\r\n    );\r\n\r\n    if (relevantSentences.length > 0) {\r\n      let description = relevantSentences[0];\r\n\r\n      description = description\r\n        .replace(new RegExp(`\\\\*\\\\*${placeName}\\\\*\\\\*`, \"gi\"), \"\")\r\n        .trim();\r\n\r\n      description = description.replace(/:/g, \"\");\r\n\r\n      description = description.replace(\r\n        /^(is|are|was|were|has|have|had|will|would|can|could|should|may|might)\\s+/i,\r\n        \"\"\r\n      );\r\n\r\n      description =\r\n        description.charAt(0).toUpperCase() + description.slice(1);\r\n\r\n      description = sanitizeLeading(description);\r\n      descriptions[placeName] = description;\r\n    }\r\n  });\r\n\r\n  console.log(\"Extracted place descriptions:\", descriptions);\r\n  return descriptions;\r\n};\r\n\r\nexport const formatMessageText = (text, foundPlaces = []) => {\r\n  if (foundPlaces.length === 0) {\r\n    return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\");\r\n  }\r\n\r\n  const foundLower = foundPlaces.map((p) => p.toLowerCase());\r\n  return text.replace(/\\*\\*(.*?)\\*\\*/g, (match, placeName) => {\r\n    const trimmedPlaceName = placeName.trim();\r\n    if (foundLower.includes(trimmedPlaceName.toLowerCase())) {\r\n      return `<span class=\"place-name clickable-place\" data-place=\"${trimmedPlaceName}\">${placeName}</span>`;\r\n    } else {\r\n      return placeName;\r\n    }\r\n  });\r\n};\r\n\r\nexport const formatItineraryToHtml = (rawText, foundPlaces = []) => {\r\n  if (!rawText) return \"\";\r\n  const normalized = rawText.replace(/\\r\\n/g, \"\\n\");\r\n  const lines = normalized\r\n    .split(\"\\n\")\r\n    .map((l) => l.replace(/^\\s*###\\s*/i, \"\").trim());\r\n\r\n  const daySections = [];\r\n  let current = null;\r\n  const dayHeaderRegex = /^#*\\s*day\\s*(\\d+)(?::|-)?\\s*(.*)$/i;\r\n\r\n  const pushCurrent = () => {\r\n    if (current) {\r\n      current.items = current.items.filter((i) => i.trim().length > 0);\r\n      daySections.push(current);\r\n      current = null;\r\n    }\r\n  };\r\n\r\n  const foundLower = foundPlaces.map((p) => p.toLowerCase());\r\n  const foundMap = {};\r\n  foundPlaces.forEach((p) => (foundMap[p.toLowerCase()] = p));\r\n\r\n  for (let rawLine of lines) {\r\n    if (!rawLine) continue;\r\n    let line = rawLine.replace(/^[-*•]\\s*/, \"\").trim();\r\n    if (!line) continue;\r\n    const m = line.match(dayHeaderRegex);\r\n    if (m) {\r\n      pushCurrent();\r\n      const dayNum = m[1];\r\n      const rest = (m[2] || \"\").trim();\r\n      current = {\r\n        title: `Day ${dayNum}${rest ? `: ${rest}` : \"\"}`,\r\n        items: [],\r\n      };\r\n      continue;\r\n    }\r\n    if (!current) continue;\r\n\r\n    let cleaned = line.replace(/^[-*•]\\s*/, \"\");\r\n    const dashIdx = cleaned.indexOf(\" - \");\r\n    let itemHtml = cleaned;\r\n    const wrapPlace = (placeLabel) => {\r\n      const original = foundMap[placeLabel.toLowerCase()] || placeLabel;\r\n      return `<span class=\\\"place-name clickable-place blue-place\\\" data-place=\\\"${original}\\\">${original}</span>`;\r\n    };\r\n\r\n    if (dashIdx > 0) {\r\n      let left = cleaned.substring(0, dashIdx).trim();\r\n      let rest = cleaned.substring(dashIdx + 3);\r\n\r\n      left = left.replace(/^[0-9]+\\.\\s*/, \"\").replace(/^[-*•]\\s*/, \"\");\r\n\r\n      const leftUnmarked = left.replace(/^\\*\\*(.*)\\*\\*$/, \"$1\").trim();\r\n\r\n      let matched = null;\r\n      if (foundLower.includes(leftUnmarked.toLowerCase())) {\r\n        matched = foundMap[leftUnmarked.toLowerCase()];\r\n      } else {\r\n        for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\r\n          if (leftUnmarked.toLowerCase().includes(p.toLowerCase())) {\r\n            matched = p;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (matched) {\r\n        const wrapped = wrapPlace(matched);\r\n        itemHtml = `${wrapped} - ${rest}`;\r\n      } else {\r\n        itemHtml = `${left} - ${rest}`;\r\n      }\r\n    } else {\r\n      const prefix = cleaned.substring(0, 60);\r\n      let matched = null;\r\n      for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\r\n        if (prefix.toLowerCase().includes(p.toLowerCase())) {\r\n          matched = p;\r\n          break;\r\n        }\r\n      }\r\n      if (matched) {\r\n        const wrapped = wrapPlace(matched);\r\n        itemHtml = cleaned.replace(new RegExp(matched.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), wrapped);\r\n      }\r\n    }\r\n\r\n    current.items.push(itemHtml);\r\n  }\r\n  pushCurrent();\r\n\r\n  if (daySections.length === 0) {\r\n    return normalized\r\n      .split(\"\\n\")\r\n      .filter((l) => l.trim().length > 0)\r\n      .map((l) => l.replace(/^\\s*###\\s*/i, \"\"))\r\n      .join(\"<br/>\");\r\n  }\r\n\r\n  const html = daySections\r\n    .map((d) => {\r\n      const itemsHtml = d.items.join(\"<br/>\");\r\n      return `<p style=\\\"margin: 0 0 14px 0;\\\"><strong>${d.title}</strong><br/>${itemsHtml}</p>`;\r\n    })\r\n    .join(\"\\n\");\r\n  return html;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
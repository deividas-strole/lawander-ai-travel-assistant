{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Deividas\\\\aaaaaMyProjects\\\\LaWander\\\\Front\\\\src\\\\pages\\\\Chat.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport { MapContainer, TileLayer, Marker, Popup } from \"react-leaflet\";\nimport L from \"leaflet\";\nimport \"leaflet/dist/leaflet.css\";\nimport \"../css/chat.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_URL = process.env.REACT_APP_API_URL;\n\n// Fix for default markers in react-leaflet\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require(\"leaflet/dist/images/marker-icon-2x.png\"),\n  iconUrl: require(\"leaflet/dist/images/marker-icon.png\"),\n  shadowUrl: require(\"leaflet/dist/images/marker-shadow.png\")\n});\n\n// Create custom colored icons for different marker types\nconst createCustomIcon = (color, emoji = \"ğŸ“\") => {\n  return L.divIcon({\n    className: \"custom-marker\",\n    html: `\n      <div style=\"\n        background-color: ${color};\n        width: 25px;\n        height: 25px;\n        border-radius: 50% 50% 50% 0;\n        transform: rotate(-45deg);\n        border: 2px solid white;\n        box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      \">\n        <div style=\"\n          transform: rotate(45deg);\n          color: white;\n          font-size: 12px;\n          font-weight: bold;\n        \">${emoji}</div>\n      </div>\n    `,\n    iconSize: [25, 25],\n    iconAnchor: [12, 24],\n    popupAnchor: [0, -24]\n  });\n};\n\n// Color scheme for different place types\nconst getMarkerColor = (placeType, placeName) => {\n  const name = placeName.toLowerCase();\n  if (placeType === \"destination\") {\n    return {\n      color: \"#ff69b4\",\n      emoji: \"ğŸ™ï¸\"\n    };\n  }\n  if (name.includes(\"museum\") || name.includes(\"gallery\") || name.includes(\"castle\") || name.includes(\"exhibition\")) {\n    return {\n      color: \"#8B4513\",\n      emoji: \"ğŸ›ï¸\"\n    };\n  }\n  if (name.includes(\"restaurant\") || name.includes(\"cafe\") || name.includes(\"bar\") || name.includes(\"food\") || name.includes(\"dining\") || name.includes(\"kitchen\") || name.includes(\"pub\") || name.includes(\"grille\") || name.includes(\"dinner\") || name.includes(\"grill\") || name.includes(\"club\")) {\n    return {\n      color: \"#DC143C\",\n      emoji: \"ğŸ½ï¸\"\n    };\n  }\n  if (name.includes(\"hotel\") || name.includes(\"accommodation\") || name.includes(\"hostel\") || name.includes(\"resort\") || name.includes(\"lodge\")) {\n    return {\n      color: \"#4169E1\",\n      emoji: \"ğŸ¨\"\n    };\n  }\n  if (name.includes(\"park\") || name.includes(\"garden\") || name.includes(\"nature\") || name.includes(\"forest\") || name.includes(\"beach\")) {\n    return {\n      color: \"#228B22\",\n      emoji: \"ğŸŒ³\"\n    };\n  }\n  if (name.includes(\"church\") || name.includes(\"cathedral\") || name.includes(\"temple\") || name.includes(\"monastery\") || name.includes(\"mosque\") || name.includes(\"synagogue\")) {\n    return {\n      color: \"#9370DB\",\n      emoji: \"â›ª\"\n    };\n  }\n  if (name.includes(\"shop\") || name.includes(\"market\") || name.includes(\"mall\") || name.includes(\"store\") || name.includes(\"boutique\")) {\n    return {\n      color: \"#FF8C00\",\n      emoji: \"ğŸ›ï¸\"\n    };\n  }\n  if (name.includes(\"theater\") || name.includes(\"cinema\") || name.includes(\"concert\") || name.includes(\"show\") || name.includes(\"entertainment\")) {\n    return {\n      color: \"#FF1493\",\n      emoji: \"ğŸ­\"\n    };\n  }\n  return {\n    color: \"#1E90FF\",\n    emoji: \"ğŸ¯\"\n  };\n};\n\n// Generate specific description for popup\nconst getPlaceDescription = (placeName, fullAddress) => {\n  var _addressParts, _addressParts2;\n  const name = placeName.toLowerCase();\n  const addressParts = fullAddress.split(\",\");\n  const city = ((_addressParts = addressParts[addressParts.length - 3]) === null || _addressParts === void 0 ? void 0 : _addressParts.trim()) || ((_addressParts2 = addressParts[addressParts.length - 2]) === null || _addressParts2 === void 0 ? void 0 : _addressParts2.trim()) || \"Unknown\";\n  if (name.includes(\"museum\") || name.includes(\"gallery\") || name.includes(\"exhibition\")) {\n    if (name.includes(\"art\")) {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Art museum featuring local and international collections in ${city}`;\n    } else if (name.includes(\"history\") || name.includes(\"historical\")) {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Historical museum showcasing ${city}'s rich heritage and culture`;\n    } else if (name.includes(\"science\") || name.includes(\"natural\")) {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Science museum with interactive exhibits and natural history displays`;\n    } else {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Cultural institution featuring art, history, and science exhibits in ${city}`;\n    }\n  }\n  if (name.includes(\"restaurant\") || name.includes(\"cafe\") || name.includes(\"bar\") || name.includes(\"food\") || name.includes(\"dining\") || name.includes(\"kitchen\")) {\n    if (name.includes(\"cafe\") || name.includes(\"coffee\")) {\n      return `â˜• <strong>${placeName}</strong><br>Cozy cafe perfect for coffee, light meals, and relaxation in ${city}`;\n    } else if (name.includes(\"bar\") || name.includes(\"pub\")) {\n      return `ğŸº <strong>${placeName}</strong><br>Local bar/pub offering drinks and traditional ${city} atmosphere`;\n    } else {\n      return `ğŸ½ï¸ <strong>${placeName}</strong><br>Restaurant serving local cuisine and specialties in ${city}`;\n    }\n  }\n  if (name.includes(\"hotel\") || name.includes(\"accommodation\") || name.includes(\"hostel\") || name.includes(\"resort\") || name.includes(\"lodge\")) {\n    if (name.includes(\"hostel\")) {\n      return `ğŸ¨ <strong>${placeName}</strong><br>Budget-friendly hostel accommodation in the heart of ${city}`;\n    } else if (name.includes(\"resort\")) {\n      return `ğŸ¨ <strong>${placeName}</strong><br>Luxury resort with amenities and services in ${city}`;\n    } else {\n      return `ğŸ¨ <strong>${placeName}</strong><br>Hotel accommodation offering comfort and convenience in ${city}`;\n    }\n  }\n  if (name.includes(\"park\") || name.includes(\"garden\") || name.includes(\"nature\") || name.includes(\"forest\") || name.includes(\"beach\")) {\n    if (name.includes(\"botanical\") || name.includes(\"garden\")) {\n      return `ğŸŒ³ <strong>${placeName}</strong><br>Botanical garden featuring diverse plant collections and peaceful walking paths`;\n    } else if (name.includes(\"national\") || name.includes(\"forest\")) {\n      return `ğŸŒ² <strong>${placeName}</strong><br>National park with hiking trails and natural beauty`;\n    } else if (name.includes(\"beach\")) {\n      return `ğŸ–ï¸ <strong>${placeName}</strong><br>Beautiful beach area perfect for relaxation and water activities`;\n    } else {\n      return `ğŸŒ³ <strong>${placeName}</strong><br>Public park offering green spaces and recreational activities in ${city}`;\n    }\n  }\n  if (name.includes(\"church\") || name.includes(\"cathedral\") || name.includes(\"temple\") || name.includes(\"mosque\") || name.includes(\"synagogue\")) {\n    if (name.includes(\"cathedral\")) {\n      return `â›ª <strong>${placeName}</strong><br>Historic cathedral with stunning architecture and religious significance`;\n    } else if (name.includes(\"temple\")) {\n      return `ğŸ•‰ï¸ <strong>${placeName}</strong><br>Sacred temple representing spiritual heritage in ${city}`;\n    } else {\n      return `â›ª <strong>${placeName}</strong><br>Historic church with cultural and architectural importance`;\n    }\n  }\n  if (name.includes(\"shop\") || name.includes(\"market\") || name.includes(\"mall\") || name.includes(\"store\") || name.includes(\"boutique\")) {\n    if (name.includes(\"market\")) {\n      return `ğŸ›’ <strong>${placeName}</strong><br>Local market offering fresh produce and traditional goods`;\n    } else if (name.includes(\"boutique\")) {\n      return `ğŸ‘— <strong>${placeName}</strong><br>Boutique shop featuring unique fashion and local crafts`;\n    } else {\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Shopping destination for local goods and souvenirs in ${city}`;\n    }\n  }\n  if (name.includes(\"theater\") || name.includes(\"cinema\") || name.includes(\"concert\") || name.includes(\"show\") || name.includes(\"entertainment\")) {\n    if (name.includes(\"theater\") || name.includes(\"theatre\")) {\n      return `ğŸ­ <strong>${placeName}</strong><br>Theater venue hosting plays, performances, and cultural events`;\n    } else if (name.includes(\"cinema\") || name.includes(\"movie\")) {\n      return `ğŸ¬ <strong>${placeName}</strong><br>Cinema showing latest films and cultural screenings`;\n    } else {\n      return `ğŸª <strong>${placeName}</strong><br>Entertainment venue for shows, concerts, and performances`;\n    }\n  }\n  if (name.includes(\"castle\") || name.includes(\"fortress\")) {\n    return `ğŸ° <strong>${placeName}</strong><br>Historic castle/fortress with rich history and architectural beauty`;\n  } else if (name.includes(\"tower\") || name.includes(\"monument\")) {\n    return `ğŸ—¼ <strong>${placeName}</strong><br>Iconic landmark and monument representing ${city}'s heritage`;\n  } else if (name.includes(\"square\") || name.includes(\"plaza\")) {\n    return `ğŸ›ï¸ <strong>${placeName}</strong><br>Historic square/plaza in the heart of ${city}`;\n  } else {\n    return `ğŸ¯ <strong>${placeName}</strong><br>Notable attraction worth visiting during your time in ${city}`;\n  }\n};\n\n// Remove leading markdown-like tokens from popup text only (e.g. ###, -, *, bullets)\nconst sanitizeLeading = s => {\n  if (!s && s !== \"\") return s;\n  const str = String(s);\n  // Remove leading whitespace and any combination of #, -, *, bullets, colons and surrounding spaces\n  return str.replace(/^\\s*(?:[#\\-\\*\\u2022]+[\\s:]*)+/, \"\").trim();\n};\nfunction Chat({\n  destination,\n  days,\n  onBackToWelcome\n}) {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [inputMessage, setInputMessage] = useState(\"\");\n  const [mapCenter, setMapCenter] = useState([51.505, -0.09]);\n  const [destinationMarker, setDestinationMarker] = useState(null);\n  const [placeMarkers, setPlaceMarkers] = useState([]);\n  const markerRefs = useRef({});\n  const messagesEndRef = React.useRef(null);\n  const itineraryRunRef = React.useRef(\"\");\n  const scrollToBottom = () => {\n    var _messagesEndRef$curre;\n    (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n      behavior: \"smooth\"\n    });\n  };\n  const extractPlaceNames = text => {\n    console.log(\"Extracting place names from text:\", text);\n    const regex = /\\*\\*(.*?)\\*\\*/g;\n    const matches = [];\n    let match;\n    while ((match = regex.exec(text)) !== null) {\n      matches.push(match[1].trim());\n    }\n    console.log(\"Found matches:\", matches);\n    return matches;\n  };\n  const extractPlaceDescriptions = (text, placeNames) => {\n    const descriptions = {};\n\n    // Create a copy of the AI text with Day headers removed so titles like\n    // \"Day 1: Introduction to Kaunas\" don't become part of place descriptions.\n    // This does not modify the original `text` used for the itinerary rendering.\n    const textForDescriptions = String(text).replace(/^[ \\t]*[-*â€¢]?\\s*#*\\s*day\\s*\\d+(?::|-)?\\s*.*$/gim, \"\\n\");\n    const sentences = textForDescriptions.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);\n    placeNames.forEach(placeName => {\n      const relevantSentences = sentences.filter(sentence => sentence.toLowerCase().includes(placeName.toLowerCase()));\n      if (relevantSentences.length > 0) {\n        let description = relevantSentences[0];\n        description = description.replace(new RegExp(`\\\\*\\\\*${placeName}\\\\*\\\\*`, \"gi\"), \"\").trim();\n        description = description.replace(/:/g, \"\");\n        description = description.replace(/^(is|are|was|were|has|have|had|will|would|can|could|should|may|might)\\s+/i, \"\");\n        description = description.charAt(0).toUpperCase() + description.slice(1);\n\n        // Sanitize leading tokens from the extracted sentence before storing\n        // so marker popups don't include day headers or stray bullets.\n        description = sanitizeLeading(description);\n        descriptions[placeName] = description;\n      }\n    });\n    console.log(\"Extracted place descriptions:\", descriptions);\n    return descriptions;\n  };\n  const formatMessageText = (text, foundPlaces = []) => {\n    if (foundPlaces.length === 0) {\n      return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\");\n    }\n    const foundLower = foundPlaces.map(p => p.toLowerCase());\n    return text.replace(/\\*\\*(.*?)\\*\\*/g, (match, placeName) => {\n      const trimmedPlaceName = placeName.trim();\n      if (foundLower.includes(trimmedPlaceName.toLowerCase())) {\n        return `<span class=\"place-name clickable-place\" data-place=\"${trimmedPlaceName}\">${placeName}</span>`;\n      } else {\n        return placeName;\n      }\n    });\n  };\n  const formatItineraryToHtml = (rawText, foundPlaces = []) => {\n    if (!rawText) return \"\";\n    const normalized = rawText.replace(/\\r\\n/g, \"\\n\");\n    const lines = normalized.split(\"\\n\").map(l => l.replace(/^\\s*###\\s*/i, \"\").trim());\n    const daySections = [];\n    let current = null;\n    const dayHeaderRegex = /^#*\\s*day\\s*(\\d+)(?::|-)?\\s*(.*)$/i;\n    const pushCurrent = () => {\n      if (current) {\n        current.items = current.items.filter(i => i.trim().length > 0);\n        daySections.push(current);\n        current = null;\n      }\n    };\n\n    // Lowercase found places for matching, but keep original map for exact labels\n    const foundLower = foundPlaces.map(p => p.toLowerCase());\n    const foundMap = {};\n    foundPlaces.forEach(p => foundMap[p.toLowerCase()] = p);\n    for (let rawLine of lines) {\n      if (!rawLine) continue;\n      let line = rawLine.replace(/^[-*â€¢]\\s*/, \"\").trim();\n      if (!line) continue;\n      const m = line.match(dayHeaderRegex);\n      if (m) {\n        pushCurrent();\n        const dayNum = m[1];\n        const rest = (m[2] || \"\").trim();\n        current = {\n          title: `Day ${dayNum}${rest ? `: ${rest}` : \"\"}`,\n          items: []\n        };\n        continue;\n      }\n      if (!current) continue;\n      // Only highlight the first word(s) before the ' - '\n      let cleaned = line.replace(/^[-*â€¢]\\s*/, \"\");\n      const dashIdx = cleaned.indexOf(\" - \");\n      let itemHtml = cleaned;\n      const wrapPlace = placeLabel => {\n        // use original label from foundMap if available to ensure data-place matches marker keys\n        const original = foundMap[placeLabel.toLowerCase()] || placeLabel;\n        return `<span class=\\\"place-name clickable-place blue-place\\\" data-place=\\\"${original}\\\">${original}</span>`;\n      };\n      if (dashIdx > 0) {\n        let left = cleaned.substring(0, dashIdx).trim();\n        let rest = cleaned.substring(dashIdx + 3);\n\n        // Remove leading numbering like '1.' or '*' etc.\n        left = left.replace(/^[0-9]+\\.\\s*/, \"\").replace(/^[-*â€¢]\\s*/, \"\");\n\n        // If left is wrapped in **, remove those\n        const leftUnmarked = left.replace(/^\\*\\*(.*)\\*\\*$/, \"$1\").trim();\n\n        // Try exact match first\n        let matched = null;\n        if (foundLower.includes(leftUnmarked.toLowerCase())) {\n          matched = foundMap[leftUnmarked.toLowerCase()];\n        } else {\n          // Otherwise find any foundPlace that appears in the left part (longest match preferred)\n          for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\n            if (leftUnmarked.toLowerCase().includes(p.toLowerCase())) {\n              matched = p;\n              break;\n            }\n          }\n        }\n        if (matched) {\n          const wrapped = wrapPlace(matched);\n          itemHtml = `${wrapped} - ${rest}`;\n        } else {\n          itemHtml = `${left} - ${rest}`;\n        }\n      } else {\n        // No dash found: as a fallback, check the first 40 characters for any foundPlace and wrap the first match\n        const prefix = cleaned.substring(0, 60);\n        let matched = null;\n        for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\n          if (prefix.toLowerCase().includes(p.toLowerCase())) {\n            matched = p;\n            break;\n          }\n        }\n        if (matched) {\n          const wrapped = wrapPlace(matched);\n          // replace only the first occurrence\n          itemHtml = cleaned.replace(new RegExp(matched.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), wrapped);\n        }\n      }\n      current.items.push(itemHtml);\n    }\n    pushCurrent();\n    if (daySections.length === 0) {\n      return normalized.split(\"\\n\").filter(l => l.trim().length > 0).map(l => l.replace(/^\\s*###\\s*/i, \"\")).join(\"<br/>\");\n    }\n    const html = daySections.map(d => {\n      const itemsHtml = d.items.join(\"<br/>\");\n      return `<p style=\\\"margin: 0 0 14px 0;\\\"><strong>${d.title}</strong><br/>${itemsHtml}</p>`;\n    }).join(\"\\n\");\n    return html;\n  };\n  const geocodePlaces = async (placeNames, placeDescriptions = {}, destCoords = null) => {\n    console.log(\"=== GEOCODING PLACES ===\");\n    console.log(\"Place names:\", placeNames);\n    console.log(\"Destination coords:\", destCoords);\n    if (!destCoords) {\n      console.error(\"âŒ CRITICAL: No destination coordinates provided - cannot filter places!\");\n      return [];\n    }\n    const newMarkers = [];\n    const foundPlaces = [];\n    const geocodeSinglePlace = async placeName => {\n      try {\n        const city = destination;\n        console.log(`\\nğŸ” Geocoding: \"${placeName}\"`);\n\n        // Create multiple query variations\n        const searchQueries = [];\n\n        // For museums, try without \"Museum\" first\n        if (placeName.toLowerCase().includes(\"museum\")) {\n          const nameWithoutMuseum = placeName.replace(/museum/gi, \"\").trim();\n          searchQueries.push(`${nameWithoutMuseum} ${city}`);\n          searchQueries.push(`${nameWithoutMuseum} AnykÅ¡Äiai`); // with Lithuanian chars\n          searchQueries.push(`museum ${city}`);\n        }\n\n        // Try exact name with city\n        searchQueries.push(`${placeName} ${city}`);\n        searchQueries.push(`${placeName} AnykÅ¡Äiai`);\n\n        // Try without city (broader search)\n        searchQueries.push(placeName);\n\n        // Try generic fallbacks for types\n        const lowerName = placeName.toLowerCase();\n        if (lowerName.includes(\"church\") || lowerName.includes(\"matthew\")) {\n          searchQueries.push(`church ${city}`);\n          searchQueries.push(`baÅ¾nyÄia AnykÅ¡Äiai`);\n        }\n        //\n        if (lowerName.includes(\"park\")) {\n          searchQueries.push(`park ${city}`);\n          searchQueries.push(`${city} regional park`);\n        }\n        if (lowerName.includes(\"restaurant\") || lowerName.includes(\"cafe\")) {\n          searchQueries.push(`restaurant ${city}`);\n          searchQueries.push(`cafe ${city}`);\n        }\n        if (lowerName.includes(\"spa\")) {\n          searchQueries.push(`spa ${city}`);\n          searchQueries.push(`SPA Vilnius ${city}`);\n        }\n        if (lowerName.includes(\"stone\") || lowerName.includes(\"puntukas\")) {\n          searchQueries.push(`Puntukas ${city}`);\n          searchQueries.push(`Puntukas stone`);\n        }\n        if (lowerName.includes(\"tree\") || lowerName.includes(\"canopy\") || lowerName.includes(\"treetop\")) {\n          searchQueries.push(`treetop path ${city}`);\n          searchQueries.push(`laju takas`);\n        }\n        const calculateDistance = (lat1, lon1, lat2, lon2) => {\n          const R = 6371;\n          const dLat = (lat2 - lat1) * Math.PI / 180;\n          const dLon = (lon2 - lon1) * Math.PI / 180;\n          const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n          return R * c;\n        };\n        let found = false;\n        for (const query of searchQueries) {\n          console.log(`   Trying: \"${query}\"`);\n          const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=15&addressdetails=1`);\n          const data = await response.json();\n          if (data && data.length > 0) {\n            console.log(`   â†’ Got ${data.length} results`);\n            const resultsWithDistance = data.map(item => {\n              const dist = calculateDistance(destCoords[0], destCoords[1], parseFloat(item.lat), parseFloat(item.lon));\n              return {\n                ...item,\n                distance: dist\n              };\n            });\n\n            // Filter to within 50km\n            const nearbyResults = resultsWithDistance.filter(item => item.distance <= 50);\n            if (nearbyResults.length === 0) {\n              console.log(`   âŒ No results within 50km`);\n              continue;\n            }\n            console.log(`   âœ“ ${nearbyResults.length} within 50km`);\n\n            // Sort by distance\n            nearbyResults.sort((a, b) => a.distance - b.distance);\n            const bestMatch = nearbyResults[0];\n            const {\n              lat,\n              lon,\n              display_name,\n              distance\n            } = bestMatch;\n            const coordinates = [parseFloat(lat), parseFloat(lon)];\n            console.log(`   âœ… FOUND: ${display_name.substring(0, 70)}`);\n            console.log(`      Distance: ${distance.toFixed(1)}km`);\n            newMarkers.push({\n              position: coordinates,\n              popup: `${placeName}<br><small>${display_name}</small>`,\n              type: \"place\",\n              placeName: placeName,\n              fullAddress: display_name,\n              aiDescription: placeDescriptions[placeName] || null\n            });\n            foundPlaces.push(placeName);\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          console.log(`   âŒ NOT FOUND: \"${placeName}\"`);\n        }\n      } catch (error) {\n        console.error(`   âŒ ERROR: ${placeName}:`, error);\n      }\n    };\n    const concurrency = 3;\n    let idx = 0;\n    async function runBatch() {\n      const batch = [];\n      for (let i = 0; i < concurrency && idx < placeNames.length; i++, idx++) {\n        batch.push(geocodeSinglePlace(placeNames[idx]));\n      }\n      await Promise.all(batch);\n      if (idx < placeNames.length) {\n        await new Promise(resolve => setTimeout(resolve, 300));\n        return runBatch();\n      }\n    }\n    await runBatch();\n    if (newMarkers.length > 0) {\n      setPlaceMarkers(prev => {\n        const allMarkers = [...prev, ...newMarkers];\n        const seen = new Set();\n        return allMarkers.filter(m => {\n          if (seen.has(m.placeName)) return false;\n          seen.add(m.placeName);\n          return true;\n        });\n      });\n      console.log(`\\nâœ… Added ${newMarkers.length} markers to map`);\n    } else {\n      console.log(\"\\nâŒ No markers were added\");\n    }\n    const notFoundPlaces = placeNames.filter(name => !foundPlaces.includes(name));\n    if (notFoundPlaces.length > 0) {\n      console.log(`âš ï¸ Not found: ${notFoundPlaces.join(\", \")}`);\n    }\n    return foundPlaces;\n  };\n  const geocodeDestination = React.useCallback(async destinationName => {\n    try {\n      console.log(\"Geocoding destination:\", destinationName);\n      const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(destinationName)}&limit=1`);\n      const data = await response.json();\n      console.log(\"Geocoding response:\", data);\n      if (data && data.length > 0) {\n        const {\n          lat,\n          lon\n        } = data[0];\n        const coordinates = [parseFloat(lat), parseFloat(lon)];\n        console.log(\"Found coordinates:\", coordinates);\n        setMapCenter(coordinates);\n        setDestinationMarker({\n          position: coordinates,\n          popup: `${destinationName} - Your destination for ${days} days`,\n          type: \"destination\",\n          placeName: destinationName,\n          fullAddress: `${destinationName}, ${data[0].display_name}`\n        });\n        return coordinates;\n      } else {\n        console.log(\"No results found for:\", destinationName);\n      }\n    } catch (error) {\n      console.error(\"Geocoding error:\", error);\n    }\n    return null;\n  }, [days]);\n  useEffect(() => {\n    (async () => {\n      if (!destination || !days) return;\n      const runKey = `${String(destination).trim().toLowerCase()}|${String(days).trim()}`;\n      if (itineraryRunRef.current === runKey) {\n        console.log(\"â­ï¸ Skipping duplicate itinerary generation for\", runKey);\n        return;\n      }\n      itineraryRunRef.current = runKey;\n      try {\n        setMessages([{\n          id: 0,\n          text: \"Generating your itinerary...I'm slow because I'm free! ğŸ¢ğŸ¢ğŸ¢\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isLoading: true\n        }]);\n        console.log(\"ğŸ”° Starting itinerary generation for\", destination, days);\n\n        // CRITICAL: Geocode destination FIRST and wait for it\n        const destCoords = await geocodeDestination(destination);\n        if (!destCoords) {\n          throw new Error(\"Could not geocode destination\");\n        }\n        console.log(\"âœ… Destination geocoded:\", destCoords);\n        const itineraryPrompt = `Create a concise, practical ${days}-day travel itinerary for ${destination}.\n\nCRITICAL REQUIREMENTS:\n- ONLY include major, well-known attractions, landmarks, and establishments\n- Use simple, commonly-known names (e.g., \"Old Town\" not \"Historic Old Quarter\")\n- Avoid specific restaurant/cafe/bar names unless they're very famous\n- Focus on parks, churches, museums, main squares, rivers, etc.\n- For every place, wrap the name in **double asterisks**\n- Provide 3-6 items per day with short descriptions\n\nExample format:\n**Main Cathedral** - Description\n**City Park** - Description\n**Old Town Square** - Description\n`;\n        const response = await fetch(`${API_URL}/api/chat`, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            message: itineraryPrompt\n          })\n        });\n        if (!response.ok) throw new Error(`HTTP error ${response.status}`);\n        const data = await response.json();\n        const placeNames = extractPlaceNames(data.message);\n        const placeDescriptions = extractPlaceDescriptions(data.message, placeNames);\n        let foundPlaces = [];\n        if (placeNames.length > 0) {\n          // Pass destination coordinates explicitly\n          foundPlaces = await geocodePlaces(placeNames, placeDescriptions, destCoords);\n        }\n        const welcomeMessage = {\n          id: 1,\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isWelcome: true\n        };\n        setMessages([{\n          id: 0,\n          text: `Here is a suggested ${days}-day itinerary for ${destination}:<br/><br/>${formatItineraryToHtml(data.message, foundPlaces)}`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          foundPlaces,\n          isItinerary: true\n        }, welcomeMessage]);\n      } catch (err) {\n        console.error(\"Failed to generate itinerary:\", err);\n        const welcomeMessage = {\n          id: 1,\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isWelcome: true\n        };\n        setMessages([{\n          id: 0,\n          text: \"Could not generate itinerary automatically. You can ask for suggestions in the chat.\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString()\n        }, welcomeMessage]);\n      }\n    })();\n  }, [destination, days, geocodeDestination]);\n  useEffect(() => {\n    scrollToBottom();\n    const handleClick = e => {\n      const target = e.target;\n      if (target.classList.contains(\"clickable-place\")) {\n        const placeName = target.getAttribute(\"data-place\");\n        const ref = markerRefs.current[placeName];\n        if (ref && ref.current && ref.current.openPopup) {\n          ref.current.openPopup();\n        }\n      }\n    };\n    document.addEventListener(\"click\", handleClick);\n    return () => {\n      document.removeEventListener(\"click\", handleClick);\n    };\n  }, [messages, placeMarkers]);\n  const handleSendMessage = async e => {\n    e.preventDefault();\n    if (!inputMessage.trim()) return;\n    const newMessage = {\n      id: messages.length + 1,\n      text: inputMessage,\n      sender: \"user\",\n      timestamp: new Date().toLocaleTimeString()\n    };\n    setMessages([...messages, newMessage]);\n    const userMessage = inputMessage;\n    setInputMessage(\"\");\n    const loadingMessage = {\n      id: messages.length + 2,\n      text: \"LaWander is thinking...\",\n      sender: \"ai\",\n      timestamp: new Date().toLocaleTimeString(),\n      isLoading: true\n    };\n    setMessages(prev => [...prev, loadingMessage]);\n    try {\n      const contextualMessage = `Context: The user is planning a ${days}-day trip to ${destination}. \n\nIMPORTANT INSTRUCTIONS:\n- If the user asks for a specific type of place (restaurants, museums, hotels, etc.), ONLY provide places of that exact type\n- ALL places must be located in or very near ${destination}\n- When mentioning places, use the format **PlaceName** for each place\n- Be specific and accurate about locations - only include places that are actually in ${destination}\n- For each place you mention, provide a brief description (1-2 sentences) about what makes it special or what it offers\n- Include practical information like cuisine type, atmosphere, or unique features\n\nUser question: ${userMessage}`;\n      const response = await fetch(`${API_URL}/api/chat`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          message: contextualMessage\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      const placeNames = extractPlaceNames(data.message);\n      console.log(\"AI Response:\", data.message);\n      console.log(\"Extracted place names:\", placeNames);\n      const placeDescriptions = extractPlaceDescriptions(data.message, placeNames);\n      let foundPlaces = [];\n      if (placeNames.length > 0) {\n        console.log(\"Starting geocoding for\", placeNames.length, \"places\");\n        const destCoords = destinationMarker ? destinationMarker.position : null;\n        foundPlaces = await geocodePlaces(placeNames, placeDescriptions, destCoords);\n      } else {\n        console.log(\"No place names found in AI response\");\n      }\n      setMessages(prev => {\n        const withoutLoading = prev.filter(msg => !msg.isLoading);\n        const aiResponse = {\n          id: withoutLoading.length + 1,\n          text: data.message,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          foundPlaces: foundPlaces\n        };\n        return [...withoutLoading, aiResponse];\n      });\n    } catch (error) {\n      console.error(\"Error calling chat API:\", error);\n      setMessages(prev => {\n        const withoutLoading = prev.filter(msg => !msg.isLoading);\n        const errorResponse = {\n          id: withoutLoading.length + 1,\n          text: \"Sorry, I'm having trouble connecting to the server. Please try again later.\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString()\n        };\n        return [...withoutLoading, errorResponse];\n      });\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chat-app\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"header-left\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"back-button\",\n          onClick: onBackToWelcome,\n          children: \"\\u2190 Change Trip\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 935,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n          className: \"chat-title\",\n          children: \"LaWander\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 938,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 934,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"trip-info\",\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"destination\",\n          children: destination\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 941,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"days\",\n          children: [days, \" days\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 942,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 940,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 933,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"chat-window\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"messages-container\",\n          children: [messages.map(message => /*#__PURE__*/_jsxDEV(\"div\", {\n            className: `message ${message.sender === \"user\" ? \"user-message\" : \"ai-message\"}`,\n            children: /*#__PURE__*/_jsxDEV(\"div\", {\n              className: `message-content ${message.isLoading ? \"loading\" : \"\"} ${message.isItinerary ? \"itinerary\" : \"\"}`,\n              children: [/*#__PURE__*/_jsxDEV(\"p\", {\n                dangerouslySetInnerHTML: {\n                  __html: formatMessageText(message.text, message.foundPlaces)\n                }\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 959,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"message-time\",\n                children: message.timestamp\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 967,\n                columnNumber: 19\n              }, this)]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 955,\n              columnNumber: 17\n            }, this)\n          }, message.id, false, {\n            fileName: _jsxFileName,\n            lineNumber: 950,\n            columnNumber: 15\n          }, this)), /*#__PURE__*/_jsxDEV(\"div\", {\n            ref: messagesEndRef\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 971,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 948,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n          className: \"message-form\",\n          onSubmit: handleSendMessage,\n          children: [/*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"text\",\n            value: inputMessage,\n            onChange: e => setInputMessage(e.target.value),\n            placeholder: \"Ask about your destination...\",\n            className: \"message-input\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 975,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            type: \"submit\",\n            className: \"send-button\",\n            children: \"Send\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 982,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 974,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 947,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"map-container\",\n        children: /*#__PURE__*/_jsxDEV(MapContainer, {\n          center: mapCenter,\n          zoom: 13,\n          style: {\n            height: \"100%\",\n            width: \"100%\"\n          },\n          children: [/*#__PURE__*/_jsxDEV(TileLayer, {\n            attribution: \"\\xA9 <a href=\\\"https://www.openstreetmap.org/copyright\\\">OpenStreetMap</a> contributors\",\n            url: \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 995,\n            columnNumber: 13\n          }, this), destinationMarker && (() => {\n            const colorInfo = getMarkerColor(destinationMarker.type, destinationMarker.placeName);\n            const popupContent = `ğŸ™ï¸ <strong>${destinationMarker.placeName}</strong><br><small>Your destination for ${days} days</small>`;\n            return /*#__PURE__*/_jsxDEV(Marker, {\n              position: destinationMarker.position,\n              icon: createCustomIcon(colorInfo.color, colorInfo.emoji),\n              children: /*#__PURE__*/_jsxDEV(Popup, {\n                children: /*#__PURE__*/_jsxDEV(\"div\", {\n                  dangerouslySetInnerHTML: {\n                    __html: sanitizeLeading(popupContent)\n                  }\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1009,\n                  columnNumber: 21\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1008,\n                columnNumber: 19\n              }, this)\n            }, \"destination\", false, {\n              fileName: _jsxFileName,\n              lineNumber: 1003,\n              columnNumber: 17\n            }, this);\n          })(), placeMarkers.map((marker, index) => {\n            const colorInfo = getMarkerColor(marker.type, marker.placeName);\n            // Build and sanitize raw description (may already include title)\n            const rawDesc = marker.aiDescription || getPlaceDescription(marker.placeName, marker.fullAddress);\n            const safeDesc = sanitizeLeading(rawDesc || \"\");\n            const placeLower = (marker.placeName || \"\").toLowerCase();\n            // If the sanitized description already contains the place name very near the start, use it as-is to avoid duplication\n            const firstIndex = safeDesc.toLowerCase().indexOf(placeLower);\n            let popupContent;\n            if (firstIndex >= 0 && firstIndex < 30) {\n              // Description already has the place title near start â€” use sanitized description\n              popupContent = safeDesc;\n            } else {\n              // Otherwise, prefix with emoji + strong title\n              popupContent = `${colorInfo.emoji} <strong>${marker.placeName}</strong><br>${safeDesc}`;\n            }\n            if (!markerRefs.current[marker.placeName]) {\n              markerRefs.current[marker.placeName] = /*#__PURE__*/React.createRef();\n            }\n            return /*#__PURE__*/_jsxDEV(Marker, {\n              position: marker.position,\n              icon: createCustomIcon(colorInfo.color, colorInfo.emoji),\n              ref: markerRefs.current[marker.placeName],\n              children: /*#__PURE__*/_jsxDEV(Popup, {\n                children: /*#__PURE__*/_jsxDEV(\"div\", {\n                  dangerouslySetInnerHTML: {\n                    __html: popupContent\n                  }\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 1041,\n                  columnNumber: 21\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 1040,\n                columnNumber: 19\n              }, this)\n            }, marker.placeName + index, false, {\n              fileName: _jsxFileName,\n              lineNumber: 1034,\n              columnNumber: 17\n            }, this);\n          })]\n        }, `${mapCenter[0]}-${mapCenter[1]}`, true, {\n          fileName: _jsxFileName,\n          lineNumber: 989,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 988,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 946,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 932,\n    columnNumber: 5\n  }, this);\n}\n_s(Chat, \"AqiR9686Kr2GkeHotaFMHNAz/MI=\");\n_c = Chat;\nexport default Chat;\nvar _c;\n$RefreshReg$(_c, \"Chat\");","map":{"version":3,"names":["React","useState","useEffect","useRef","MapContainer","TileLayer","Marker","Popup","L","jsxDEV","_jsxDEV","API_URL","process","env","REACT_APP_API_URL","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","require","iconUrl","shadowUrl","createCustomIcon","color","emoji","divIcon","className","html","iconSize","iconAnchor","popupAnchor","getMarkerColor","placeType","placeName","name","toLowerCase","includes","getPlaceDescription","fullAddress","_addressParts","_addressParts2","addressParts","split","city","length","trim","sanitizeLeading","s","str","String","replace","Chat","destination","days","onBackToWelcome","_s","messages","setMessages","inputMessage","setInputMessage","mapCenter","setMapCenter","destinationMarker","setDestinationMarker","placeMarkers","setPlaceMarkers","markerRefs","messagesEndRef","itineraryRunRef","scrollToBottom","_messagesEndRef$curre","current","scrollIntoView","behavior","extractPlaceNames","text","console","log","regex","matches","match","exec","push","extractPlaceDescriptions","placeNames","descriptions","textForDescriptions","sentences","map","filter","forEach","relevantSentences","sentence","description","RegExp","charAt","toUpperCase","slice","formatMessageText","foundPlaces","foundLower","p","trimmedPlaceName","formatItineraryToHtml","rawText","normalized","lines","l","daySections","dayHeaderRegex","pushCurrent","items","i","foundMap","rawLine","line","m","dayNum","rest","title","cleaned","dashIdx","indexOf","itemHtml","wrapPlace","placeLabel","original","left","substring","leftUnmarked","matched","sort","a","b","wrapped","prefix","join","d","itemsHtml","geocodePlaces","placeDescriptions","destCoords","error","newMarkers","geocodeSinglePlace","searchQueries","nameWithoutMuseum","lowerName","calculateDistance","lat1","lon1","lat2","lon2","R","dLat","Math","PI","dLon","sin","cos","c","atan2","sqrt","found","query","response","fetch","encodeURIComponent","data","json","resultsWithDistance","item","dist","parseFloat","lat","lon","distance","nearbyResults","bestMatch","display_name","coordinates","toFixed","position","popup","type","aiDescription","concurrency","idx","runBatch","batch","Promise","all","resolve","setTimeout","prev","allMarkers","seen","Set","has","add","notFoundPlaces","geocodeDestination","useCallback","destinationName","runKey","id","sender","timestamp","Date","toLocaleTimeString","isLoading","Error","itineraryPrompt","method","headers","body","JSON","stringify","message","ok","status","welcomeMessage","isWelcome","isItinerary","err","handleClick","e","target","classList","contains","getAttribute","ref","openPopup","document","addEventListener","removeEventListener","handleSendMessage","preventDefault","newMessage","userMessage","loadingMessage","contextualMessage","withoutLoading","msg","aiResponse","errorResponse","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","dangerouslySetInnerHTML","__html","onSubmit","value","onChange","placeholder","center","zoom","style","height","width","attribution","url","colorInfo","popupContent","icon","marker","index","rawDesc","safeDesc","placeLower","firstIndex","createRef","_c","$RefreshReg$"],"sources":["C:/Users/Deividas/aaaaaMyProjects/LaWander/Front/src/pages/Chat.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\r\nimport { MapContainer, TileLayer, Marker, Popup } from \"react-leaflet\";\r\nimport L from \"leaflet\";\r\nimport \"leaflet/dist/leaflet.css\";\r\nimport \"../css/chat.css\";\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL;\r\n\r\n// Fix for default markers in react-leaflet\r\ndelete L.Icon.Default.prototype._getIconUrl;\r\nL.Icon.Default.mergeOptions({\r\n  iconRetinaUrl: require(\"leaflet/dist/images/marker-icon-2x.png\"),\r\n  iconUrl: require(\"leaflet/dist/images/marker-icon.png\"),\r\n  shadowUrl: require(\"leaflet/dist/images/marker-shadow.png\"),\r\n});\r\n\r\n// Create custom colored icons for different marker types\r\nconst createCustomIcon = (color, emoji = \"ğŸ“\") => {\r\n  return L.divIcon({\r\n    className: \"custom-marker\",\r\n    html: `\r\n      <div style=\"\r\n        background-color: ${color};\r\n        width: 25px;\r\n        height: 25px;\r\n        border-radius: 50% 50% 50% 0;\r\n        transform: rotate(-45deg);\r\n        border: 2px solid white;\r\n        box-shadow: 0 2px 4px rgba(0,0,0,0.3);\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n      \">\r\n        <div style=\"\r\n          transform: rotate(45deg);\r\n          color: white;\r\n          font-size: 12px;\r\n          font-weight: bold;\r\n        \">${emoji}</div>\r\n      </div>\r\n    `,\r\n    iconSize: [25, 25],\r\n    iconAnchor: [12, 24],\r\n    popupAnchor: [0, -24],\r\n  });\r\n};\r\n\r\n// Color scheme for different place types\r\nconst getMarkerColor = (placeType, placeName) => {\r\n  const name = placeName.toLowerCase();\r\n\r\n  if (placeType === \"destination\") {\r\n    return { color: \"#ff69b4\", emoji: \"ğŸ™ï¸\" };\r\n  }\r\n\r\n  if (\r\n    name.includes(\"museum\") ||\r\n    name.includes(\"gallery\") ||\r\n    name.includes(\"castle\") ||\r\n    name.includes(\"exhibition\")\r\n  ) {\r\n    return { color: \"#8B4513\", emoji: \"ğŸ›ï¸\" };\r\n  }\r\n\r\n  if (\r\n    name.includes(\"restaurant\") ||\r\n    name.includes(\"cafe\") ||\r\n    name.includes(\"bar\") ||\r\n    name.includes(\"food\") ||\r\n    name.includes(\"dining\") ||\r\n    name.includes(\"kitchen\") ||\r\n    name.includes(\"pub\") ||\r\n    name.includes(\"grille\") ||\r\n    name.includes(\"dinner\") ||\r\n    name.includes(\"grill\") ||\r\n    name.includes(\"club\")\r\n  ) {\r\n    return { color: \"#DC143C\", emoji: \"ğŸ½ï¸\" };\r\n  }\r\n\r\n  if (\r\n    name.includes(\"hotel\") ||\r\n    name.includes(\"accommodation\") ||\r\n    name.includes(\"hostel\") ||\r\n    name.includes(\"resort\") ||\r\n    name.includes(\"lodge\")\r\n  ) {\r\n    return { color: \"#4169E1\", emoji: \"ğŸ¨\" };\r\n  }\r\n\r\n  if (\r\n    name.includes(\"park\") ||\r\n    name.includes(\"garden\") ||\r\n    name.includes(\"nature\") ||\r\n    name.includes(\"forest\") ||\r\n    name.includes(\"beach\")\r\n  ) {\r\n    return { color: \"#228B22\", emoji: \"ğŸŒ³\" };\r\n  }\r\n\r\n  if (\r\n    name.includes(\"church\") ||\r\n    name.includes(\"cathedral\") ||\r\n    name.includes(\"temple\") ||\r\n    name.includes(\"monastery\") ||\r\n    name.includes(\"mosque\") ||\r\n    name.includes(\"synagogue\")\r\n  ) {\r\n    return { color: \"#9370DB\", emoji: \"â›ª\" };\r\n  }\r\n\r\n  if (\r\n    name.includes(\"shop\") ||\r\n    name.includes(\"market\") ||\r\n    name.includes(\"mall\") ||\r\n    name.includes(\"store\") ||\r\n    name.includes(\"boutique\")\r\n  ) {\r\n    return { color: \"#FF8C00\", emoji: \"ğŸ›ï¸\" };\r\n  }\r\n\r\n  if (\r\n    name.includes(\"theater\") ||\r\n    name.includes(\"cinema\") ||\r\n    name.includes(\"concert\") ||\r\n    name.includes(\"show\") ||\r\n    name.includes(\"entertainment\")\r\n  ) {\r\n    return { color: \"#FF1493\", emoji: \"ğŸ­\" };\r\n  }\r\n\r\n  return { color: \"#1E90FF\", emoji: \"ğŸ¯\" };\r\n};\r\n\r\n// Generate specific description for popup\r\nconst getPlaceDescription = (placeName, fullAddress) => {\r\n  const name = placeName.toLowerCase();\r\n\r\n  const addressParts = fullAddress.split(\",\");\r\n  const city =\r\n    addressParts[addressParts.length - 3]?.trim() ||\r\n    addressParts[addressParts.length - 2]?.trim() ||\r\n    \"Unknown\";\r\n\r\n  if (\r\n    name.includes(\"museum\") ||\r\n    name.includes(\"gallery\") ||\r\n    name.includes(\"exhibition\")\r\n  ) {\r\n    if (name.includes(\"art\")) {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Art museum featuring local and international collections in ${city}`;\r\n    } else if (name.includes(\"history\") || name.includes(\"historical\")) {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Historical museum showcasing ${city}'s rich heritage and culture`;\r\n    } else if (name.includes(\"science\") || name.includes(\"natural\")) {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Science museum with interactive exhibits and natural history displays`;\r\n    } else {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Cultural institution featuring art, history, and science exhibits in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"restaurant\") ||\r\n    name.includes(\"cafe\") ||\r\n    name.includes(\"bar\") ||\r\n    name.includes(\"food\") ||\r\n    name.includes(\"dining\") ||\r\n    name.includes(\"kitchen\")\r\n  ) {\r\n    if (name.includes(\"cafe\") || name.includes(\"coffee\")) {\r\n      return `â˜• <strong>${placeName}</strong><br>Cozy cafe perfect for coffee, light meals, and relaxation in ${city}`;\r\n    } else if (name.includes(\"bar\") || name.includes(\"pub\")) {\r\n      return `ğŸº <strong>${placeName}</strong><br>Local bar/pub offering drinks and traditional ${city} atmosphere`;\r\n    } else {\r\n      return `ğŸ½ï¸ <strong>${placeName}</strong><br>Restaurant serving local cuisine and specialties in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"hotel\") ||\r\n    name.includes(\"accommodation\") ||\r\n    name.includes(\"hostel\") ||\r\n    name.includes(\"resort\") ||\r\n    name.includes(\"lodge\")\r\n  ) {\r\n    if (name.includes(\"hostel\")) {\r\n      return `ğŸ¨ <strong>${placeName}</strong><br>Budget-friendly hostel accommodation in the heart of ${city}`;\r\n    } else if (name.includes(\"resort\")) {\r\n      return `ğŸ¨ <strong>${placeName}</strong><br>Luxury resort with amenities and services in ${city}`;\r\n    } else {\r\n      return `ğŸ¨ <strong>${placeName}</strong><br>Hotel accommodation offering comfort and convenience in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"park\") ||\r\n    name.includes(\"garden\") ||\r\n    name.includes(\"nature\") ||\r\n    name.includes(\"forest\") ||\r\n    name.includes(\"beach\")\r\n  ) {\r\n    if (name.includes(\"botanical\") || name.includes(\"garden\")) {\r\n      return `ğŸŒ³ <strong>${placeName}</strong><br>Botanical garden featuring diverse plant collections and peaceful walking paths`;\r\n    } else if (name.includes(\"national\") || name.includes(\"forest\")) {\r\n      return `ğŸŒ² <strong>${placeName}</strong><br>National park with hiking trails and natural beauty`;\r\n    } else if (name.includes(\"beach\")) {\r\n      return `ğŸ–ï¸ <strong>${placeName}</strong><br>Beautiful beach area perfect for relaxation and water activities`;\r\n    } else {\r\n      return `ğŸŒ³ <strong>${placeName}</strong><br>Public park offering green spaces and recreational activities in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"church\") ||\r\n    name.includes(\"cathedral\") ||\r\n    name.includes(\"temple\") ||\r\n    name.includes(\"mosque\") ||\r\n    name.includes(\"synagogue\")\r\n  ) {\r\n    if (name.includes(\"cathedral\")) {\r\n      return `â›ª <strong>${placeName}</strong><br>Historic cathedral with stunning architecture and religious significance`;\r\n    } else if (name.includes(\"temple\")) {\r\n      return `ğŸ•‰ï¸ <strong>${placeName}</strong><br>Sacred temple representing spiritual heritage in ${city}`;\r\n    } else {\r\n      return `â›ª <strong>${placeName}</strong><br>Historic church with cultural and architectural importance`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"shop\") ||\r\n    name.includes(\"market\") ||\r\n    name.includes(\"mall\") ||\r\n    name.includes(\"store\") ||\r\n    name.includes(\"boutique\")\r\n  ) {\r\n    if (name.includes(\"market\")) {\r\n      return `ğŸ›’ <strong>${placeName}</strong><br>Local market offering fresh produce and traditional goods`;\r\n    } else if (name.includes(\"boutique\")) {\r\n      return `ğŸ‘— <strong>${placeName}</strong><br>Boutique shop featuring unique fashion and local crafts`;\r\n    } else {\r\n      return `ğŸ›ï¸ <strong>${placeName}</strong><br>Shopping destination for local goods and souvenirs in ${city}`;\r\n    }\r\n  }\r\n\r\n  if (\r\n    name.includes(\"theater\") ||\r\n    name.includes(\"cinema\") ||\r\n    name.includes(\"concert\") ||\r\n    name.includes(\"show\") ||\r\n    name.includes(\"entertainment\")\r\n  ) {\r\n    if (name.includes(\"theater\") || name.includes(\"theatre\")) {\r\n      return `ğŸ­ <strong>${placeName}</strong><br>Theater venue hosting plays, performances, and cultural events`;\r\n    } else if (name.includes(\"cinema\") || name.includes(\"movie\")) {\r\n      return `ğŸ¬ <strong>${placeName}</strong><br>Cinema showing latest films and cultural screenings`;\r\n    } else {\r\n      return `ğŸª <strong>${placeName}</strong><br>Entertainment venue for shows, concerts, and performances`;\r\n    }\r\n  }\r\n\r\n  if (name.includes(\"castle\") || name.includes(\"fortress\")) {\r\n    return `ğŸ° <strong>${placeName}</strong><br>Historic castle/fortress with rich history and architectural beauty`;\r\n  } else if (name.includes(\"tower\") || name.includes(\"monument\")) {\r\n    return `ğŸ—¼ <strong>${placeName}</strong><br>Iconic landmark and monument representing ${city}'s heritage`;\r\n  } else if (name.includes(\"square\") || name.includes(\"plaza\")) {\r\n    return `ğŸ›ï¸ <strong>${placeName}</strong><br>Historic square/plaza in the heart of ${city}`;\r\n  } else {\r\n    return `ğŸ¯ <strong>${placeName}</strong><br>Notable attraction worth visiting during your time in ${city}`;\r\n  }\r\n};\r\n\r\n// Remove leading markdown-like tokens from popup text only (e.g. ###, -, *, bullets)\r\nconst sanitizeLeading = (s) => {\r\n  if (!s && s !== \"\") return s;\r\n  const str = String(s);\r\n  // Remove leading whitespace and any combination of #, -, *, bullets, colons and surrounding spaces\r\n  return str.replace(/^\\s*(?:[#\\-\\*\\u2022]+[\\s:]*)+/, \"\").trim();\r\n};\r\n\r\nfunction Chat({ destination, days, onBackToWelcome }) {\r\n  const [messages, setMessages] = useState([]);\r\n  const [inputMessage, setInputMessage] = useState(\"\");\r\n  const [mapCenter, setMapCenter] = useState([51.505, -0.09]);\r\n  const [destinationMarker, setDestinationMarker] = useState(null);\r\n  const [placeMarkers, setPlaceMarkers] = useState([]);\r\n  const markerRefs = useRef({});\r\n  const messagesEndRef = React.useRef(null);\r\n  const itineraryRunRef = React.useRef(\"\");\r\n\r\n  const scrollToBottom = () => {\r\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\r\n  };\r\n\r\n  const extractPlaceNames = (text) => {\r\n    console.log(\"Extracting place names from text:\", text);\r\n    const regex = /\\*\\*(.*?)\\*\\*/g;\r\n    const matches = [];\r\n    let match;\r\n    while ((match = regex.exec(text)) !== null) {\r\n      matches.push(match[1].trim());\r\n    }\r\n    console.log(\"Found matches:\", matches);\r\n    return matches;\r\n  };\r\n\r\n  const extractPlaceDescriptions = (text, placeNames) => {\r\n    const descriptions = {};\r\n\r\n    // Create a copy of the AI text with Day headers removed so titles like\r\n    // \"Day 1: Introduction to Kaunas\" don't become part of place descriptions.\r\n    // This does not modify the original `text` used for the itinerary rendering.\r\n    const textForDescriptions = String(text).replace(/^[ \\t]*[-*â€¢]?\\s*#*\\s*day\\s*\\d+(?::|-)?\\s*.*$/gim, \"\\n\");\r\n\r\n    const sentences = textForDescriptions\r\n      .split(/[.!?]+/)\r\n      .map((s) => s.trim())\r\n      .filter((s) => s.length > 0);\r\n\r\n    placeNames.forEach((placeName) => {\r\n      const relevantSentences = sentences.filter((sentence) =>\r\n        sentence.toLowerCase().includes(placeName.toLowerCase())\r\n      );\r\n\r\n      if (relevantSentences.length > 0) {\r\n        let description = relevantSentences[0];\r\n\r\n        description = description\r\n          .replace(new RegExp(`\\\\*\\\\*${placeName}\\\\*\\\\*`, \"gi\"), \"\")\r\n          .trim();\r\n\r\n        description = description.replace(/:/g, \"\");\r\n\r\n        description = description.replace(\r\n          /^(is|are|was|were|has|have|had|will|would|can|could|should|may|might)\\s+/i,\r\n          \"\"\r\n        );\r\n\r\n        description =\r\n          description.charAt(0).toUpperCase() + description.slice(1);\r\n\r\n        // Sanitize leading tokens from the extracted sentence before storing\r\n        // so marker popups don't include day headers or stray bullets.\r\n        description = sanitizeLeading(description);\r\n        descriptions[placeName] = description;\r\n      }\r\n    });\r\n\r\n    console.log(\"Extracted place descriptions:\", descriptions);\r\n    return descriptions;\r\n  };\r\n\r\n  const formatMessageText = (text, foundPlaces = []) => {\r\n    if (foundPlaces.length === 0) {\r\n      return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\");\r\n    }\r\n\r\n    const foundLower = foundPlaces.map((p) => p.toLowerCase());\r\n    return text.replace(/\\*\\*(.*?)\\*\\*/g, (match, placeName) => {\r\n      const trimmedPlaceName = placeName.trim();\r\n      if (foundLower.includes(trimmedPlaceName.toLowerCase())) {\r\n        return `<span class=\"place-name clickable-place\" data-place=\"${trimmedPlaceName}\">${placeName}</span>`;\r\n      } else {\r\n        return placeName;\r\n      }\r\n    });\r\n  };\r\n\r\n  const formatItineraryToHtml = (rawText, foundPlaces = []) => {\r\n    if (!rawText) return \"\";\r\n    const normalized = rawText.replace(/\\r\\n/g, \"\\n\");\r\n    const lines = normalized\r\n      .split(\"\\n\")\r\n      .map((l) => l.replace(/^\\s*###\\s*/i, \"\").trim());\r\n\r\n    const daySections = [];\r\n    let current = null;\r\n    const dayHeaderRegex = /^#*\\s*day\\s*(\\d+)(?::|-)?\\s*(.*)$/i;\r\n\r\n    const pushCurrent = () => {\r\n      if (current) {\r\n        current.items = current.items.filter((i) => i.trim().length > 0);\r\n        daySections.push(current);\r\n        current = null;\r\n      }\r\n    };\r\n\r\n    // Lowercase found places for matching, but keep original map for exact labels\r\n    const foundLower = foundPlaces.map((p) => p.toLowerCase());\r\n    const foundMap = {};\r\n    foundPlaces.forEach((p) => (foundMap[p.toLowerCase()] = p));\r\n\r\n    for (let rawLine of lines) {\r\n      if (!rawLine) continue;\r\n      let line = rawLine.replace(/^[-*â€¢]\\s*/, \"\").trim();\r\n      if (!line) continue;\r\n      const m = line.match(dayHeaderRegex);\r\n      if (m) {\r\n        pushCurrent();\r\n        const dayNum = m[1];\r\n        const rest = (m[2] || \"\").trim();\r\n        current = {\r\n          title: `Day ${dayNum}${rest ? `: ${rest}` : \"\"}`,\r\n          items: [],\r\n        };\r\n        continue;\r\n      }\r\n      if (!current) continue;\r\n      // Only highlight the first word(s) before the ' - '\r\n      let cleaned = line.replace(/^[-*â€¢]\\s*/, \"\");\r\n      const dashIdx = cleaned.indexOf(\" - \");\r\n      let itemHtml = cleaned;\r\n      const wrapPlace = (placeLabel) => {\r\n        // use original label from foundMap if available to ensure data-place matches marker keys\r\n        const original = foundMap[placeLabel.toLowerCase()] || placeLabel;\r\n        return `<span class=\\\"place-name clickable-place blue-place\\\" data-place=\\\"${original}\\\">${original}</span>`;\r\n      };\r\n\r\n      if (dashIdx > 0) {\r\n        let left = cleaned.substring(0, dashIdx).trim();\r\n        let rest = cleaned.substring(dashIdx + 3);\r\n\r\n        // Remove leading numbering like '1.' or '*' etc.\r\n        left = left.replace(/^[0-9]+\\.\\s*/, \"\").replace(/^[-*â€¢]\\s*/, \"\");\r\n\r\n        // If left is wrapped in **, remove those\r\n        const leftUnmarked = left.replace(/^\\*\\*(.*)\\*\\*$/, \"$1\").trim();\r\n\r\n        // Try exact match first\r\n        let matched = null;\r\n        if (foundLower.includes(leftUnmarked.toLowerCase())) {\r\n          matched = foundMap[leftUnmarked.toLowerCase()];\r\n        } else {\r\n          // Otherwise find any foundPlace that appears in the left part (longest match preferred)\r\n          for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\r\n            if (leftUnmarked.toLowerCase().includes(p.toLowerCase())) {\r\n              matched = p;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (matched) {\r\n          const wrapped = wrapPlace(matched);\r\n          itemHtml = `${wrapped} - ${rest}`;\r\n        } else {\r\n          itemHtml = `${left} - ${rest}`;\r\n        }\r\n      } else {\r\n        // No dash found: as a fallback, check the first 40 characters for any foundPlace and wrap the first match\r\n        const prefix = cleaned.substring(0, 60);\r\n        let matched = null;\r\n        for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\r\n          if (prefix.toLowerCase().includes(p.toLowerCase())) {\r\n            matched = p;\r\n            break;\r\n          }\r\n        }\r\n        if (matched) {\r\n          const wrapped = wrapPlace(matched);\r\n          // replace only the first occurrence\r\n          itemHtml = cleaned.replace(new RegExp(matched.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), wrapped);\r\n        }\r\n      }\r\n\r\n      current.items.push(itemHtml);\r\n    }\r\n    pushCurrent();\r\n\r\n    if (daySections.length === 0) {\r\n      return normalized\r\n        .split(\"\\n\")\r\n        .filter((l) => l.trim().length > 0)\r\n        .map((l) => l.replace(/^\\s*###\\s*/i, \"\"))\r\n        .join(\"<br/>\");\r\n    }\r\n\r\n    const html = daySections\r\n      .map((d) => {\r\n        const itemsHtml = d.items.join(\"<br/>\");\r\n        return `<p style=\\\"margin: 0 0 14px 0;\\\"><strong>${d.title}</strong><br/>${itemsHtml}</p>`;\r\n      })\r\n      .join(\"\\n\");\r\n    return html;\r\n  };\r\n\r\n  const geocodePlaces = async (placeNames, placeDescriptions = {}, destCoords = null) => {\r\n    console.log(\"=== GEOCODING PLACES ===\");\r\n    console.log(\"Place names:\", placeNames);\r\n    console.log(\"Destination coords:\", destCoords);\r\n\r\n    if (!destCoords) {\r\n      console.error(\"âŒ CRITICAL: No destination coordinates provided - cannot filter places!\");\r\n      return [];\r\n    }\r\n\r\n    const newMarkers = [];\r\n    const foundPlaces = [];\r\n\r\n    const geocodeSinglePlace = async (placeName) => {\r\n      try {\r\n        const city = destination;\r\n\r\n        console.log(`\\nğŸ” Geocoding: \"${placeName}\"`);\r\n\r\n        // Create multiple query variations\r\n        const searchQueries = [];\r\n\r\n        // For museums, try without \"Museum\" first\r\n        if (placeName.toLowerCase().includes(\"museum\")) {\r\n          const nameWithoutMuseum = placeName.replace(/museum/gi, \"\").trim();\r\n          searchQueries.push(`${nameWithoutMuseum} ${city}`);\r\n          searchQueries.push(`${nameWithoutMuseum} AnykÅ¡Äiai`); // with Lithuanian chars\r\n          searchQueries.push(`museum ${city}`);\r\n        }\r\n\r\n        // Try exact name with city\r\n        searchQueries.push(`${placeName} ${city}`);\r\n        searchQueries.push(`${placeName} AnykÅ¡Äiai`);\r\n\r\n        // Try without city (broader search)\r\n        searchQueries.push(placeName);\r\n\r\n        // Try generic fallbacks for types\r\n        const lowerName = placeName.toLowerCase();\r\n        if (lowerName.includes(\"church\") || lowerName.includes(\"matthew\")) {\r\n          searchQueries.push(`church ${city}`);\r\n          searchQueries.push(`baÅ¾nyÄia AnykÅ¡Äiai`);\r\n        }\r\n        //\r\n        if (lowerName.includes(\"park\")) {\r\n          searchQueries.push(`park ${city}`);\r\n          searchQueries.push(`${city} regional park`);\r\n        }\r\n        if (lowerName.includes(\"restaurant\") || lowerName.includes(\"cafe\")) {\r\n          searchQueries.push(`restaurant ${city}`);\r\n          searchQueries.push(`cafe ${city}`);\r\n        }\r\n        if (lowerName.includes(\"spa\")) {\r\n          searchQueries.push(`spa ${city}`);\r\n          searchQueries.push(`SPA Vilnius ${city}`);\r\n        }\r\n        if (lowerName.includes(\"stone\") || lowerName.includes(\"puntukas\")) {\r\n          searchQueries.push(`Puntukas ${city}`);\r\n          searchQueries.push(`Puntukas stone`);\r\n        }\r\n        if (lowerName.includes(\"tree\") || lowerName.includes(\"canopy\") || lowerName.includes(\"treetop\")) {\r\n          searchQueries.push(`treetop path ${city}`);\r\n          searchQueries.push(`laju takas`);\r\n        }\r\n\r\n        const calculateDistance = (lat1, lon1, lat2, lon2) => {\r\n          const R = 6371;\r\n          const dLat = (lat2 - lat1) * Math.PI / 180;\r\n          const dLon = (lon2 - lon1) * Math.PI / 180;\r\n          const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\r\n            Math.sin(dLon / 2) * Math.sin(dLon / 2);\r\n          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n          return R * c;\r\n        };\r\n\r\n        let found = false;\r\n        for (const query of searchQueries) {\r\n          console.log(`   Trying: \"${query}\"`);\r\n\r\n          const response = await fetch(\r\n            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=15&addressdetails=1`\r\n          );\r\n          const data = await response.json();\r\n\r\n          if (data && data.length > 0) {\r\n            console.log(`   â†’ Got ${data.length} results`);\r\n\r\n            const resultsWithDistance = data.map(item => {\r\n              const dist = calculateDistance(\r\n                destCoords[0], destCoords[1],\r\n                parseFloat(item.lat), parseFloat(item.lon)\r\n              );\r\n              return { ...item, distance: dist };\r\n            });\r\n\r\n            // Filter to within 50km\r\n            const nearbyResults = resultsWithDistance.filter(item => item.distance <= 50);\r\n\r\n            if (nearbyResults.length === 0) {\r\n              console.log(`   âŒ No results within 50km`);\r\n              continue;\r\n            }\r\n\r\n            console.log(`   âœ“ ${nearbyResults.length} within 50km`);\r\n\r\n            // Sort by distance\r\n            nearbyResults.sort((a, b) => a.distance - b.distance);\r\n\r\n            const bestMatch = nearbyResults[0];\r\n            const { lat, lon, display_name, distance } = bestMatch;\r\n            const coordinates = [parseFloat(lat), parseFloat(lon)];\r\n\r\n            console.log(`   âœ… FOUND: ${display_name.substring(0, 70)}`);\r\n            console.log(`      Distance: ${distance.toFixed(1)}km`);\r\n\r\n            newMarkers.push({\r\n              position: coordinates,\r\n              popup: `${placeName}<br><small>${display_name}</small>`,\r\n              type: \"place\",\r\n              placeName: placeName,\r\n              fullAddress: display_name,\r\n              aiDescription: placeDescriptions[placeName] || null,\r\n            });\r\n            foundPlaces.push(placeName);\r\n            found = true;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!found) {\r\n          console.log(`   âŒ NOT FOUND: \"${placeName}\"`);\r\n        }\r\n      } catch (error) {\r\n        console.error(`   âŒ ERROR: ${placeName}:`, error);\r\n      }\r\n    };\r\n\r\n    const concurrency = 3;\r\n    let idx = 0;\r\n    async function runBatch() {\r\n      const batch = [];\r\n      for (let i = 0; i < concurrency && idx < placeNames.length; i++, idx++) {\r\n        batch.push(geocodeSinglePlace(placeNames[idx]));\r\n      }\r\n      await Promise.all(batch);\r\n      if (idx < placeNames.length) {\r\n        await new Promise((resolve) => setTimeout(resolve, 300));\r\n        return runBatch();\r\n      }\r\n    }\r\n    await runBatch();\r\n\r\n    if (newMarkers.length > 0) {\r\n      setPlaceMarkers((prev) => {\r\n        const allMarkers = [...prev, ...newMarkers];\r\n        const seen = new Set();\r\n        return allMarkers.filter(m => {\r\n          if (seen.has(m.placeName)) return false;\r\n          seen.add(m.placeName);\r\n          return true;\r\n        });\r\n      });\r\n      console.log(`\\nâœ… Added ${newMarkers.length} markers to map`);\r\n    } else {\r\n      console.log(\"\\nâŒ No markers were added\");\r\n    }\r\n\r\n    const notFoundPlaces = placeNames.filter((name) => !foundPlaces.includes(name));\r\n    if (notFoundPlaces.length > 0) {\r\n      console.log(`âš ï¸ Not found: ${notFoundPlaces.join(\", \")}`);\r\n    }\r\n\r\n    return foundPlaces;\r\n  };\r\n\r\n  const geocodeDestination = React.useCallback(\r\n    async (destinationName) => {\r\n      try {\r\n        console.log(\"Geocoding destination:\", destinationName);\r\n        const response = await fetch(\r\n          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(\r\n            destinationName\r\n          )}&limit=1`\r\n        );\r\n        const data = await response.json();\r\n        console.log(\"Geocoding response:\", data);\r\n\r\n        if (data && data.length > 0) {\r\n          const { lat, lon } = data[0];\r\n          const coordinates = [parseFloat(lat), parseFloat(lon)];\r\n          console.log(\"Found coordinates:\", coordinates);\r\n\r\n          setMapCenter(coordinates);\r\n\r\n          setDestinationMarker({\r\n            position: coordinates,\r\n            popup: `${destinationName} - Your destination for ${days} days`,\r\n            type: \"destination\",\r\n            placeName: destinationName,\r\n            fullAddress: `${destinationName}, ${data[0].display_name}`,\r\n          });\r\n\r\n          return coordinates;\r\n        } else {\r\n          console.log(\"No results found for:\", destinationName);\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Geocoding error:\", error);\r\n      }\r\n      return null;\r\n    },\r\n    [days]\r\n  );\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      if (!destination || !days) return;\r\n      const runKey = `${String(destination).trim().toLowerCase()}|${String(\r\n        days\r\n      ).trim()}`;\r\n      if (itineraryRunRef.current === runKey) {\r\n        console.log(\"â­ï¸ Skipping duplicate itinerary generation for\", runKey);\r\n        return;\r\n      }\r\n      itineraryRunRef.current = runKey;\r\n\r\n      try {\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: \"Generating your itinerary...I'm slow because I'm free! ğŸ¢ğŸ¢ğŸ¢\",\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n            isLoading: true,\r\n          },\r\n        ]);\r\n\r\n        console.log(\"ğŸ”° Starting itinerary generation for\", destination, days);\r\n\r\n        // CRITICAL: Geocode destination FIRST and wait for it\r\n        const destCoords = await geocodeDestination(destination);\r\n\r\n        if (!destCoords) {\r\n          throw new Error(\"Could not geocode destination\");\r\n        }\r\n\r\n        console.log(\"âœ… Destination geocoded:\", destCoords);\r\n\r\n        const itineraryPrompt = `Create a concise, practical ${days}-day travel itinerary for ${destination}.\r\n\r\nCRITICAL REQUIREMENTS:\r\n- ONLY include major, well-known attractions, landmarks, and establishments\r\n- Use simple, commonly-known names (e.g., \"Old Town\" not \"Historic Old Quarter\")\r\n- Avoid specific restaurant/cafe/bar names unless they're very famous\r\n- Focus on parks, churches, museums, main squares, rivers, etc.\r\n- For every place, wrap the name in **double asterisks**\r\n- Provide 3-6 items per day with short descriptions\r\n\r\nExample format:\r\n**Main Cathedral** - Description\r\n**City Park** - Description\r\n**Old Town Square** - Description\r\n`;\r\n\r\n        const response = await fetch(`${API_URL}/api/chat`, {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({ message: itineraryPrompt }),\r\n        });\r\n\r\n        if (!response.ok) throw new Error(`HTTP error ${response.status}`);\r\n        const data = await response.json();\r\n\r\n        const placeNames = extractPlaceNames(data.message);\r\n        const placeDescriptions = extractPlaceDescriptions(\r\n          data.message,\r\n          placeNames\r\n        );\r\n\r\n        let foundPlaces = [];\r\n        if (placeNames.length > 0) {\r\n          // Pass destination coordinates explicitly\r\n          foundPlaces = await geocodePlaces(placeNames, placeDescriptions, destCoords);\r\n        }\r\n\r\n        const welcomeMessage = {\r\n          id: 1,\r\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          isWelcome: true,\r\n        };\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: `Here is a suggested ${days}-day itinerary for ${destination}:<br/><br/>${formatItineraryToHtml(\r\n              data.message,\r\n              foundPlaces\r\n            )}`,\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n            foundPlaces,\r\n            isItinerary: true,\r\n          },\r\n          welcomeMessage,\r\n        ]);\r\n      } catch (err) {\r\n        console.error(\"Failed to generate itinerary:\", err);\r\n        const welcomeMessage = {\r\n          id: 1,\r\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          isWelcome: true,\r\n        };\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: \"Could not generate itinerary automatically. You can ask for suggestions in the chat.\",\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n          },\r\n          welcomeMessage,\r\n        ]);\r\n      }\r\n    })();\r\n  }, [destination, days, geocodeDestination]);\r\n\r\n  useEffect(() => {\r\n    scrollToBottom();\r\n\r\n    const handleClick = (e) => {\r\n      const target = e.target;\r\n      if (target.classList.contains(\"clickable-place\")) {\r\n        const placeName = target.getAttribute(\"data-place\");\r\n        const ref = markerRefs.current[placeName];\r\n        if (ref && ref.current && ref.current.openPopup) {\r\n          ref.current.openPopup();\r\n        }\r\n      }\r\n    };\r\n    document.addEventListener(\"click\", handleClick);\r\n    return () => {\r\n      document.removeEventListener(\"click\", handleClick);\r\n    };\r\n  }, [messages, placeMarkers]);\r\n\r\n  const handleSendMessage = async (e) => {\r\n    e.preventDefault();\r\n    if (!inputMessage.trim()) return;\r\n\r\n    const newMessage = {\r\n      id: messages.length + 1,\r\n      text: inputMessage,\r\n      sender: \"user\",\r\n      timestamp: new Date().toLocaleTimeString(),\r\n    };\r\n\r\n    setMessages([...messages, newMessage]);\r\n    const userMessage = inputMessage;\r\n    setInputMessage(\"\");\r\n\r\n    const loadingMessage = {\r\n      id: messages.length + 2,\r\n      text: \"LaWander is thinking...\",\r\n      sender: \"ai\",\r\n      timestamp: new Date().toLocaleTimeString(),\r\n      isLoading: true,\r\n    };\r\n    setMessages((prev) => [...prev, loadingMessage]);\r\n\r\n    try {\r\n      const contextualMessage = `Context: The user is planning a ${days}-day trip to ${destination}. \r\n\r\nIMPORTANT INSTRUCTIONS:\r\n- If the user asks for a specific type of place (restaurants, museums, hotels, etc.), ONLY provide places of that exact type\r\n- ALL places must be located in or very near ${destination}\r\n- When mentioning places, use the format **PlaceName** for each place\r\n- Be specific and accurate about locations - only include places that are actually in ${destination}\r\n- For each place you mention, provide a brief description (1-2 sentences) about what makes it special or what it offers\r\n- Include practical information like cuisine type, atmosphere, or unique features\r\n\r\nUser question: ${userMessage}`;\r\n\r\n      const response = await fetch(`${API_URL}/api/chat`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n          message: contextualMessage,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      const placeNames = extractPlaceNames(data.message);\r\n      console.log(\"AI Response:\", data.message);\r\n      console.log(\"Extracted place names:\", placeNames);\r\n\r\n      const placeDescriptions = extractPlaceDescriptions(\r\n        data.message,\r\n        placeNames\r\n      );\r\n\r\n      let foundPlaces = [];\r\n      if (placeNames.length > 0) {\r\n        console.log(\"Starting geocoding for\", placeNames.length, \"places\");\r\n        const destCoords = destinationMarker ? destinationMarker.position : null;\r\n        foundPlaces = await geocodePlaces(placeNames, placeDescriptions, destCoords);\r\n      } else {\r\n        console.log(\"No place names found in AI response\");\r\n      }\r\n\r\n      setMessages((prev) => {\r\n        const withoutLoading = prev.filter((msg) => !msg.isLoading);\r\n        const aiResponse = {\r\n          id: withoutLoading.length + 1,\r\n          text: data.message,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          foundPlaces: foundPlaces,\r\n        };\r\n        return [...withoutLoading, aiResponse];\r\n      });\r\n    } catch (error) {\r\n      console.error(\"Error calling chat API:\", error);\r\n\r\n      setMessages((prev) => {\r\n        const withoutLoading = prev.filter((msg) => !msg.isLoading);\r\n        const errorResponse = {\r\n          id: withoutLoading.length + 1,\r\n          text: \"Sorry, I'm having trouble connecting to the server. Please try again later.\",\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n        };\r\n        return [...withoutLoading, errorResponse];\r\n      });\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"chat-app\">\r\n      <div className=\"chat-header\">\r\n        <div className=\"header-left\">\r\n          <button className=\"back-button\" onClick={onBackToWelcome}>\r\n            â† Change Trip\r\n          </button>\r\n          <h1 className=\"chat-title\">LaWander</h1>\r\n        </div>\r\n        <div className=\"trip-info\">\r\n          <span className=\"destination\">{destination}</span>\r\n          <span className=\"days\">{days} days</span>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"chat-container\">\r\n        <div className=\"chat-window\">\r\n          <div className=\"messages-container\">\r\n            {messages.map((message) => (\r\n              <div\r\n                key={message.id}\r\n                className={`message ${message.sender === \"user\" ? \"user-message\" : \"ai-message\"\r\n                  }`}\r\n              >\r\n                <div\r\n                  className={`message-content ${message.isLoading ? \"loading\" : \"\"\r\n                    } ${message.isItinerary ? \"itinerary\" : \"\"}`}\r\n                >\r\n                  <p\r\n                    dangerouslySetInnerHTML={{\r\n                      __html: formatMessageText(\r\n                        message.text,\r\n                        message.foundPlaces\r\n                      ),\r\n                    }}\r\n                  ></p>\r\n                  <span className=\"message-time\">{message.timestamp}</span>\r\n                </div>\r\n              </div>\r\n            ))}\r\n            <div ref={messagesEndRef} />\r\n          </div>\r\n\r\n          <form className=\"message-form\" onSubmit={handleSendMessage}>\r\n            <input\r\n              type=\"text\"\r\n              value={inputMessage}\r\n              onChange={(e) => setInputMessage(e.target.value)}\r\n              placeholder=\"Ask about your destination...\"\r\n              className=\"message-input\"\r\n            />\r\n            <button type=\"submit\" className=\"send-button\">\r\n              Send\r\n            </button>\r\n          </form>\r\n        </div>\r\n\r\n        <div className=\"map-container\">\r\n          <MapContainer\r\n            key={`${mapCenter[0]}-${mapCenter[1]}`}\r\n            center={mapCenter}\r\n            zoom={13}\r\n            style={{ height: \"100%\", width: \"100%\" }}\r\n          >\r\n            <TileLayer\r\n              attribution='&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\r\n              url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\r\n            />\r\n            {destinationMarker && (() => {\r\n              const colorInfo = getMarkerColor(destinationMarker.type, destinationMarker.placeName);\r\n              const popupContent = `ğŸ™ï¸ <strong>${destinationMarker.placeName}</strong><br><small>Your destination for ${days} days</small>`;\r\n              return (\r\n                <Marker\r\n                  key={\"destination\"}\r\n                  position={destinationMarker.position}\r\n                  icon={createCustomIcon(colorInfo.color, colorInfo.emoji)}\r\n                >\r\n                  <Popup>\r\n                    <div dangerouslySetInnerHTML={{ __html: sanitizeLeading(popupContent) }} />\r\n                  </Popup>\r\n                </Marker>\r\n              );\r\n            })()}\r\n            {placeMarkers.map((marker, index) => {\r\n              const colorInfo = getMarkerColor(marker.type, marker.placeName);\r\n              // Build and sanitize raw description (may already include title)\r\n              const rawDesc = marker.aiDescription || getPlaceDescription(marker.placeName, marker.fullAddress);\r\n              const safeDesc = sanitizeLeading(rawDesc || \"\");\r\n              const placeLower = (marker.placeName || \"\").toLowerCase();\r\n              // If the sanitized description already contains the place name very near the start, use it as-is to avoid duplication\r\n              const firstIndex = safeDesc.toLowerCase().indexOf(placeLower);\r\n              let popupContent;\r\n              if (firstIndex >= 0 && firstIndex < 30) {\r\n                // Description already has the place title near start â€” use sanitized description\r\n                popupContent = safeDesc;\r\n              } else {\r\n                // Otherwise, prefix with emoji + strong title\r\n                popupContent = `${colorInfo.emoji} <strong>${marker.placeName}</strong><br>${safeDesc}`;\r\n              }\r\n              if (!markerRefs.current[marker.placeName]) {\r\n                markerRefs.current[marker.placeName] = React.createRef();\r\n              }\r\n              return (\r\n                <Marker\r\n                  key={marker.placeName + index}\r\n                  position={marker.position}\r\n                  icon={createCustomIcon(colorInfo.color, colorInfo.emoji)}\r\n                  ref={markerRefs.current[marker.placeName]}\r\n                >\r\n                  <Popup>\r\n                    <div dangerouslySetInnerHTML={{ __html: popupContent }} />\r\n                  </Popup>\r\n                </Marker>\r\n              );\r\n            })}\r\n          </MapContainer>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\nexport default Chat;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
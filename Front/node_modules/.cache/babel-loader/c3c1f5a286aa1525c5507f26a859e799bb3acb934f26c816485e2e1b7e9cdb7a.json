{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Deividas\\\\aaaaaMyProjects\\\\LaWander\\\\Front\\\\src\\\\pages\\\\ChatNew.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from \"react\";\nimport \"../css/chat.css\";\nimport MapView from \"../components/MapView\";\nimport MessageList from \"../components/MessageList\";\nimport MessageForm from \"../components/MessageForm\";\nimport { sanitizeLeading } from \"../components/mapHelpers\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_URL = process.env.REACT_APP_API_URL;\nconst extractPlaceNames = text => {\n  console.log(\"Extracting place names from text:\", text);\n  const regex = /\\*\\*(.*?)\\*\\*/g;\n  const matches = [];\n  let match;\n  while ((match = regex.exec(text)) !== null) {\n    matches.push(match[1].trim());\n  }\n  console.log(\"Found matches:\", matches);\n  return matches;\n};\nconst extractPlaceDescriptions = (text, placeNames) => {\n  const descriptions = {};\n  const textForDescriptions = String(text).replace(/^[ \\t]*[-*‚Ä¢]?\\s*#*\\s*day\\s*\\d+(?::|-)?\\s*.*$/gim, \"\\n\");\n  const sentences = textForDescriptions.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);\n  placeNames.forEach(placeName => {\n    const relevantSentences = sentences.filter(sentence => sentence.toLowerCase().includes(placeName.toLowerCase()));\n    if (relevantSentences.length > 0) {\n      let description = relevantSentences[0];\n      description = description.replace(new RegExp(`\\\\*\\\\*${placeName}\\\\*\\\\*`, \"gi\"), \"\").trim();\n      description = description.replace(/:/g, \"\");\n      description = description.replace(/^(is|are|was|were|has|have|had|will|would|can|could|should|may|might)\\s+/i, \"\");\n      description = description.charAt(0).toUpperCase() + description.slice(1);\n      description = sanitizeLeading(description);\n      descriptions[placeName] = description;\n    }\n  });\n  console.log(\"Extracted place descriptions:\", descriptions);\n  return descriptions;\n};\nconst formatMessageText = (text, foundPlaces = []) => {\n  if (foundPlaces.length === 0) {\n    return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\");\n  }\n  const foundLower = foundPlaces.map(p => p.toLowerCase());\n  return text.replace(/\\*\\*(.*?)\\*\\*/g, (match, placeName) => {\n    const trimmedPlaceName = placeName.trim();\n    if (foundLower.includes(trimmedPlaceName.toLowerCase())) {\n      return `<span class=\"place-name clickable-place\" data-place=\"${trimmedPlaceName}\">${placeName}</span>`;\n    } else {\n      return placeName;\n    }\n  });\n};\nconst formatItineraryToHtml = (rawText, foundPlaces = []) => {\n  if (!rawText) return \"\";\n  const normalized = rawText.replace(/\\r\\n/g, \"\\n\");\n  const lines = normalized.split(\"\\n\").map(l => l.replace(/^\\s*###\\s*/i, \"\").trim());\n  const daySections = [];\n  let current = null;\n  const dayHeaderRegex = /^#*\\s*day\\s*(\\d+)(?::|-)?\\s*(.*)$/i;\n  const pushCurrent = () => {\n    if (current) {\n      current.items = current.items.filter(i => i.trim().length > 0);\n      daySections.push(current);\n      current = null;\n    }\n  };\n  const foundLower = foundPlaces.map(p => p.toLowerCase());\n  const foundMap = {};\n  foundPlaces.forEach(p => foundMap[p.toLowerCase()] = p);\n  for (let rawLine of lines) {\n    if (!rawLine) continue;\n    let line = rawLine.replace(/^[-*‚Ä¢]\\s*/, \"\").trim();\n    if (!line) continue;\n    const m = line.match(dayHeaderRegex);\n    if (m) {\n      pushCurrent();\n      const dayNum = m[1];\n      const rest = (m[2] || \"\").trim();\n      current = {\n        title: `Day ${dayNum}${rest ? `: ${rest}` : \"\"}`,\n        items: []\n      };\n      continue;\n    }\n    if (!current) continue;\n    let cleaned = line.replace(/^[-*‚Ä¢]\\s*/, \"\");\n    const dashIdx = cleaned.indexOf(\" - \");\n    let itemHtml = cleaned;\n    const wrapPlace = placeLabel => {\n      const original = foundMap[placeLabel.toLowerCase()] || placeLabel;\n      return `<span class=\\\"place-name clickable-place blue-place\\\" data-place=\\\"${original}\\\">${original}</span>`;\n    };\n    if (dashIdx > 0) {\n      let left = cleaned.substring(0, dashIdx).trim();\n      let rest = cleaned.substring(dashIdx + 3);\n      left = left.replace(/^[0-9]+\\.\\s*/, \"\").replace(/^[-*‚Ä¢]\\s*/, \"\");\n      const leftUnmarked = left.replace(/^\\*\\*(.*)\\*\\*$/, \"$1\").trim();\n      let matched = null;\n      if (foundLower.includes(leftUnmarked.toLowerCase())) {\n        matched = foundMap[leftUnmarked.toLowerCase()];\n      } else {\n        for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\n          if (leftUnmarked.toLowerCase().includes(p.toLowerCase())) {\n            matched = p;\n            break;\n          }\n        }\n      }\n      if (matched) {\n        const wrapped = wrapPlace(matched);\n        itemHtml = `${wrapped} - ${rest}`;\n      } else {\n        itemHtml = `${left} - ${rest}`;\n      }\n    } else {\n      const prefix = cleaned.substring(0, 60);\n      let matched = null;\n      for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\n        if (prefix.toLowerCase().includes(p.toLowerCase())) {\n          matched = p;\n          break;\n        }\n      }\n      if (matched) {\n        const wrapped = wrapPlace(matched);\n        itemHtml = cleaned.replace(new RegExp(matched.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), wrapped);\n      }\n    }\n    current.items.push(itemHtml);\n  }\n  pushCurrent();\n  if (daySections.length === 0) {\n    return normalized.split(\"\\n\").filter(l => l.trim().length > 0).map(l => l.replace(/^\\s*###\\s*/i, \"\")).join(\"<br/>\");\n  }\n  const html = daySections.map(d => {\n    const itemsHtml = d.items.join(\"<br/>\");\n    return `<p style=\\\"margin: 0 0 14px 0;\\\"><strong>${d.title}</strong><br/>${itemsHtml}</p>`;\n  }).join(\"\\n\");\n  return html;\n};\nconst geocodePlaces = async (placeNames, placeDescriptions = {}, destCoords = null, setPlaceMarkers, markerRefs) => {\n  console.log(\"=== GEOCODING PLACES ===\");\n  console.log(\"Place names:\", placeNames);\n  console.log(\"Destination coords:\", destCoords);\n  if (!destCoords) {\n    console.error(\"‚ùå CRITICAL: No destination coordinates provided - cannot filter places!\");\n    return [];\n  }\n  const newMarkers = [];\n  const foundPlaces = [];\n  const geocodeSinglePlace = async placeName => {\n    try {\n      const city = destCoords.cityName || \"\";\n      console.log(`\\nüîç Geocoding: \"${placeName}\"`);\n      const searchQueries = [];\n      if (placeName.toLowerCase().includes(\"museum\")) {\n        const nameWithoutMuseum = placeName.replace(/museum/gi, \"\").trim();\n        searchQueries.push(`${nameWithoutMuseum} ${city}`);\n        searchQueries.push(`${nameWithoutMuseum} Anyk≈°ƒçiai`);\n        searchQueries.push(`museum ${city}`);\n      }\n      searchQueries.push(`${placeName} ${city}`);\n      searchQueries.push(`${placeName} Anyk≈°ƒçiai`);\n      searchQueries.push(placeName);\n      const lowerName = placeName.toLowerCase();\n      if (lowerName.includes(\"church\") || lowerName.includes(\"matthew\")) {\n        searchQueries.push(`church ${city}`);\n        searchQueries.push(`ba≈ænyƒçia Anyk≈°ƒçiai`);\n      }\n      const calculateDistance = (lat1, lon1, lat2, lon2) => {\n        const R = 6371;\n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n      };\n      let found = false;\n      for (const query of searchQueries) {\n        console.log(`   Trying: \"${query}\"`);\n        const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=15&addressdetails=1`);\n        const data = await response.json();\n        if (data && data.length > 0) {\n          console.log(`   ‚Üí Got ${data.length} results`);\n          const resultsWithDistance = data.map(item => {\n            const dist = calculateDistance(destCoords[0], destCoords[1], parseFloat(item.lat), parseFloat(item.lon));\n            return {\n              ...item,\n              distance: dist\n            };\n          });\n          const nearbyResults = resultsWithDistance.filter(item => item.distance <= 50);\n          if (nearbyResults.length === 0) {\n            console.log(`   ‚ùå No results within 50km`);\n            continue;\n          }\n          nearbyResults.sort((a, b) => a.distance - b.distance);\n          const bestMatch = nearbyResults[0];\n          const {\n            lat,\n            lon,\n            display_name,\n            distance\n          } = bestMatch;\n          const coordinates = [parseFloat(lat), parseFloat(lon)];\n          console.log(`   ‚úÖ FOUND: ${display_name.substring(0, 70)}`);\n          console.log(`      Distance: ${distance.toFixed(1)}km`);\n          newMarkers.push({\n            position: coordinates,\n            popup: `${placeName}<br><small>${display_name}</small>`,\n            type: \"place\",\n            placeName: placeName,\n            fullAddress: display_name,\n            aiDescription: placeDescriptions[placeName] || null\n          });\n          foundPlaces.push(placeName);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        console.log(`   ‚ùå NOT FOUND: \"${placeName}\"`);\n      }\n    } catch (error) {\n      console.error(`   ‚ùå ERROR: ${placeName}:`, error);\n    }\n  };\n  const concurrency = 3;\n  let idx = 0;\n  async function runBatch() {\n    const batch = [];\n    for (let i = 0; i < concurrency && idx < placeNames.length; i++, idx++) {\n      batch.push(geocodeSinglePlace(placeNames[idx]));\n    }\n    await Promise.all(batch);\n    if (idx < placeNames.length) {\n      await new Promise(resolve => setTimeout(resolve, 300));\n      return runBatch();\n    }\n  }\n  await runBatch();\n  if (newMarkers.length > 0) {\n    setPlaceMarkers(prev => {\n      const allMarkers = [...prev, ...newMarkers];\n      const seen = new Set();\n      return allMarkers.filter(m => {\n        if (seen.has(m.placeName)) return false;\n        seen.add(m.placeName);\n        return true;\n      });\n    });\n    console.log(`\\n‚úÖ Added ${newMarkers.length} markers to map`);\n  } else {\n    console.log(\"\\n‚ùå No markers were added\");\n  }\n  const notFoundPlaces = placeNames.filter(name => !foundPlaces.includes(name));\n  if (notFoundPlaces.length > 0) {\n    console.log(`‚ö†Ô∏è Not found: ${notFoundPlaces.join(\", \")}`);\n  }\n  return foundPlaces;\n};\nconst geocodeDestination = async destinationName => {\n  try {\n    console.log(\"Geocoding destination:\", destinationName);\n    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(destinationName)}&limit=1`);\n    const data = await response.json();\n    console.log(\"Geocoding response:\", data);\n    if (data && data.length > 0) {\n      const {\n        lat,\n        lon\n      } = data[0];\n      const coordinates = [parseFloat(lat), parseFloat(lon)];\n      console.log(\"Found coordinates:\", coordinates);\n      return coordinates;\n    } else {\n      console.log(\"No results found for:\", destinationName);\n    }\n  } catch (error) {\n    console.error(\"Geocoding error:\", error);\n  }\n  return null;\n};\nfunction Chat({\n  destination,\n  days,\n  onBackToWelcome\n}) {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [inputMessage, setInputMessage] = useState(\"\");\n  const [mapCenter, setMapCenter] = useState([51.505, -0.09]);\n  const [destinationMarker, setDestinationMarker] = useState(null);\n  const [placeMarkers, setPlaceMarkers] = useState([]);\n  const markerRefs = useRef({});\n  const messagesEndRef = React.useRef(null);\n  const itineraryRunRef = React.useRef(\"\");\n  const scrollToBottom = () => {\n    var _messagesEndRef$curre;\n    (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({\n      behavior: \"smooth\"\n    });\n  };\n  useEffect(() => {\n    (async () => {\n      if (!destination || !days) return;\n      const runKey = `${String(destination).trim().toLowerCase()}|${String(days).trim()}`;\n      if (itineraryRunRef.current === runKey) {\n        console.log(\"‚è≠Ô∏è Skipping duplicate itinerary generation for\", runKey);\n        return;\n      }\n      itineraryRunRef.current = runKey;\n      try {\n        setMessages([{\n          id: 0,\n          text: \"Generating your itinerary...I'm slow because I'm free! üê¢üê¢üê¢\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isLoading: true\n        }]);\n        console.log(\"üî∞ Starting itinerary generation for\", destination, days);\n        const destCoords = await geocodeDestination(destination);\n        if (!destCoords) {\n          throw new Error(\"Could not geocode destination\");\n        }\n        setMapCenter(destCoords);\n        setDestinationMarker({\n          position: destCoords,\n          popup: `${destination} - Your destination for ${days} days`,\n          type: \"destination\",\n          placeName: destination,\n          fullAddress: `${destination}, ${destination}`\n        });\n        const itineraryPrompt = `Create a concise, practical ${days}-day travel itinerary for ${destination}.\n\nCRITICAL REQUIREMENTS:\n- ONLY include major, well-known attractions, landmarks, and establishments\n- Use simple, commonly-known names (e.g., \"Old Town\" not \"Historic Old Quarter\")\n- Avoid specific restaurant/cafe/bar names unless they're very famous\n- Focus on parks, churches, museums, main squares, rivers, etc.\n- For every place, wrap the name in **double asterisks**\n- Provide 3-6 items per day with short descriptions\n\nExample format:\n**Main Cathedral** - Description\n**City Park** - Description\n**Old Town Square** - Description\n`;\n        const response = await fetch(`${API_URL}/api/chat`, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            message: itineraryPrompt\n          })\n        });\n        if (!response.ok) throw new Error(`HTTP error ${response.status}`);\n        const data = await response.json();\n        const placeNames = extractPlaceNames(data.message);\n        const placeDescriptions = extractPlaceDescriptions(data.message, placeNames);\n        let foundPlaces = [];\n        if (placeNames.length > 0) {\n          foundPlaces = await geocodePlaces(placeNames, placeDescriptions, destCoords, setPlaceMarkers, markerRefs);\n        }\n        const welcomeMessage = {\n          id: 1,\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isWelcome: true\n        };\n        setMessages([{\n          id: 0,\n          text: `Here is a suggested ${days}-day itinerary for ${destination}:<br/><br/>${formatItineraryToHtml(data.message, foundPlaces)}`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          foundPlaces,\n          isItinerary: true\n        }, welcomeMessage]);\n      } catch (err) {\n        console.error(\"Failed to generate itinerary:\", err);\n        const welcomeMessage = {\n          id: 1,\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          isWelcome: true\n        };\n        setMessages([{\n          id: 0,\n          text: \"Could not generate itinerary automatically. You can ask for suggestions in the chat.\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString()\n        }, welcomeMessage]);\n      }\n    })();\n  }, [destination, days]);\n  useEffect(() => {\n    scrollToBottom();\n    const handleClick = e => {\n      const target = e.target;\n      if (target.classList.contains(\"clickable-place\")) {\n        const placeName = target.getAttribute(\"data-place\");\n        const ref = markerRefs.current[placeName];\n        if (ref && ref.current && ref.current.openPopup) {\n          ref.current.openPopup();\n        }\n      }\n    };\n    document.addEventListener(\"click\", handleClick);\n    return () => {\n      document.removeEventListener(\"click\", handleClick);\n    };\n  }, [messages, placeMarkers]);\n  const handleSendMessage = async e => {\n    e.preventDefault();\n    if (!inputMessage.trim()) return;\n    const newMessage = {\n      id: messages.length + 1,\n      text: inputMessage,\n      sender: \"user\",\n      timestamp: new Date().toLocaleTimeString()\n    };\n    setMessages([...messages, newMessage]);\n    const userMessage = inputMessage;\n    setInputMessage(\"\");\n    const loadingMessage = {\n      id: messages.length + 2,\n      text: \"LaWander is thinking...\",\n      sender: \"ai\",\n      timestamp: new Date().toLocaleTimeString(),\n      isLoading: true\n    };\n    setMessages(prev => [...prev, loadingMessage]);\n    try {\n      const contextualMessage = `Context: The user is planning a ${days}-day trip to ${destination}. \\n\\nIMPORTANT INSTRUCTIONS:\\n- If the user asks for a specific type of place (restaurants, museums, hotels, etc.), ONLY provide places of that exact type\\n- ALL places must be located in or very near ${destination}\\n- When mentioning places, use the format **PlaceName** for each place\\n- Be specific and accurate about locations - only include places that are actually in ${destination}\\n- For each place you mention, provide a brief description (1-2 sentences) about what makes it special or what it offers\\n- Include practical information like cuisine type, atmosphere, or unique features\\n\\nUser question: ${userMessage}`;\n      const response = await fetch(`${API_URL}/api/chat`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          message: contextualMessage\n        })\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      const placeNames = extractPlaceNames(data.message);\n      console.log(\"AI Response:\", data.message);\n      console.log(\"Extracted place names:\", placeNames);\n      const placeDescriptions = extractPlaceDescriptions(data.message, placeNames);\n      let foundPlaces = [];\n      if (placeNames.length > 0) {\n        console.log(\"Starting geocoding for\", placeNames.length, \"places\");\n        const destCoords = destinationMarker ? destinationMarker.position : null;\n        foundPlaces = await geocodePlaces(placeNames, placeDescriptions, destCoords, setPlaceMarkers, markerRefs);\n      } else {\n        console.log(\"No place names found in AI response\");\n      }\n      setMessages(prev => {\n        const withoutLoading = prev.filter(msg => !msg.isLoading);\n        const aiResponse = {\n          id: withoutLoading.length + 1,\n          text: data.message,\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString(),\n          foundPlaces: foundPlaces\n        };\n        return [...withoutLoading, aiResponse];\n      });\n    } catch (error) {\n      console.error(\"Error calling chat API:\", error);\n      setMessages(prev => {\n        const withoutLoading = prev.filter(msg => !msg.isLoading);\n        const errorResponse = {\n          id: withoutLoading.length + 1,\n          text: \"Sorry, I'm having trouble connecting to the server. Please try again later.\",\n          sender: \"ai\",\n          timestamp: new Date().toLocaleTimeString()\n        };\n        return [...withoutLoading, errorResponse];\n      });\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chat-app\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"header-left\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"back-button\",\n          onClick: onBackToWelcome,\n          children: \"\\u2190 Change Trip\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 596,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"h1\", {\n          className: \"chat-title\",\n          children: \"LaWander\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 599,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 595,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"trip-info\",\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"destination\",\n          children: destination\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 602,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"days\",\n          children: [days, \" days\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 603,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 601,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 594,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chat-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"chat-window\",\n        children: [/*#__PURE__*/_jsxDEV(MessageList, {\n          messages: messages,\n          formatMessageText: formatMessageText,\n          messagesEndRef: messagesEndRef\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 609,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(MessageForm, {\n          inputMessage: inputMessage,\n          setInputMessage: setInputMessage,\n          handleSendMessage: handleSendMessage\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 610,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 608,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(MapView, {\n        mapCenter: mapCenter,\n        destinationMarker: destinationMarker,\n        placeMarkers: placeMarkers,\n        days: days,\n        markerRefs: markerRefs\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 613,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 607,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 593,\n    columnNumber: 5\n  }, this);\n}\n_s(Chat, \"u8wsmOu9nZkjewqcmNsVD/TozYA=\");\n_c = Chat;\nexport default Chat;\nvar _c;\n$RefreshReg$(_c, \"Chat\");","map":{"version":3,"names":["React","useState","useEffect","useRef","MapView","MessageList","MessageForm","sanitizeLeading","jsxDEV","_jsxDEV","API_URL","process","env","REACT_APP_API_URL","extractPlaceNames","text","console","log","regex","matches","match","exec","push","trim","extractPlaceDescriptions","placeNames","descriptions","textForDescriptions","String","replace","sentences","split","map","s","filter","length","forEach","placeName","relevantSentences","sentence","toLowerCase","includes","description","RegExp","charAt","toUpperCase","slice","formatMessageText","foundPlaces","foundLower","p","trimmedPlaceName","formatItineraryToHtml","rawText","normalized","lines","l","daySections","current","dayHeaderRegex","pushCurrent","items","i","foundMap","rawLine","line","m","dayNum","rest","title","cleaned","dashIdx","indexOf","itemHtml","wrapPlace","placeLabel","original","left","substring","leftUnmarked","matched","sort","a","b","wrapped","prefix","join","html","d","itemsHtml","geocodePlaces","placeDescriptions","destCoords","setPlaceMarkers","markerRefs","error","newMarkers","geocodeSinglePlace","city","cityName","searchQueries","nameWithoutMuseum","lowerName","calculateDistance","lat1","lon1","lat2","lon2","R","dLat","Math","PI","dLon","sin","cos","c","atan2","sqrt","found","query","response","fetch","encodeURIComponent","data","json","resultsWithDistance","item","dist","parseFloat","lat","lon","distance","nearbyResults","bestMatch","display_name","coordinates","toFixed","position","popup","type","fullAddress","aiDescription","concurrency","idx","runBatch","batch","Promise","all","resolve","setTimeout","prev","allMarkers","seen","Set","has","add","notFoundPlaces","name","geocodeDestination","destinationName","Chat","destination","days","onBackToWelcome","_s","messages","setMessages","inputMessage","setInputMessage","mapCenter","setMapCenter","destinationMarker","setDestinationMarker","placeMarkers","messagesEndRef","itineraryRunRef","scrollToBottom","_messagesEndRef$curre","scrollIntoView","behavior","runKey","id","sender","timestamp","Date","toLocaleTimeString","isLoading","Error","itineraryPrompt","method","headers","body","JSON","stringify","message","ok","status","welcomeMessage","isWelcome","isItinerary","err","handleClick","e","target","classList","contains","getAttribute","ref","openPopup","document","addEventListener","removeEventListener","handleSendMessage","preventDefault","newMessage","userMessage","loadingMessage","contextualMessage","withoutLoading","msg","aiResponse","errorResponse","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Deividas/aaaaaMyProjects/LaWander/Front/src/pages/ChatNew.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\r\nimport \"../css/chat.css\";\r\n\r\nimport MapView from \"../components/MapView\";\r\nimport MessageList from \"../components/MessageList\";\r\nimport MessageForm from \"../components/MessageForm\";\r\nimport { sanitizeLeading } from \"../components/mapHelpers\";\r\n\r\nconst API_URL = process.env.REACT_APP_API_URL;\r\n\r\nconst extractPlaceNames = (text) => {\r\n  console.log(\"Extracting place names from text:\", text);\r\n  const regex = /\\*\\*(.*?)\\*\\*/g;\r\n  const matches = [];\r\n  let match;\r\n  while ((match = regex.exec(text)) !== null) {\r\n    matches.push(match[1].trim());\r\n  }\r\n  console.log(\"Found matches:\", matches);\r\n  return matches;\r\n};\r\n\r\nconst extractPlaceDescriptions = (text, placeNames) => {\r\n  const descriptions = {};\r\n\r\n  const textForDescriptions = String(text).replace(/^[ \\t]*[-*‚Ä¢]?\\s*#*\\s*day\\s*\\d+(?::|-)?\\s*.*$/gim, \"\\n\");\r\n\r\n  const sentences = textForDescriptions\r\n    .split(/[.!?]+/)\r\n    .map((s) => s.trim())\r\n    .filter((s) => s.length > 0);\r\n\r\n  placeNames.forEach((placeName) => {\r\n    const relevantSentences = sentences.filter((sentence) =>\r\n      sentence.toLowerCase().includes(placeName.toLowerCase())\r\n    );\r\n\r\n    if (relevantSentences.length > 0) {\r\n      let description = relevantSentences[0];\r\n\r\n      description = description\r\n        .replace(new RegExp(`\\\\*\\\\*${placeName}\\\\*\\\\*`, \"gi\"), \"\")\r\n        .trim();\r\n\r\n      description = description.replace(/:/g, \"\");\r\n\r\n      description = description.replace(\r\n        /^(is|are|was|were|has|have|had|will|would|can|could|should|may|might)\\s+/i,\r\n        \"\"\r\n      );\r\n\r\n      description = description.charAt(0).toUpperCase() + description.slice(1);\r\n\r\n      description = sanitizeLeading(description);\r\n      descriptions[placeName] = description;\r\n    }\r\n  });\r\n\r\n  console.log(\"Extracted place descriptions:\", descriptions);\r\n  return descriptions;\r\n};\r\n\r\nconst formatMessageText = (text, foundPlaces = []) => {\r\n  if (foundPlaces.length === 0) {\r\n    return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\");\r\n  }\r\n\r\n  const foundLower = foundPlaces.map((p) => p.toLowerCase());\r\n  return text.replace(/\\*\\*(.*?)\\*\\*/g, (match, placeName) => {\r\n    const trimmedPlaceName = placeName.trim();\r\n    if (foundLower.includes(trimmedPlaceName.toLowerCase())) {\r\n      return `<span class=\"place-name clickable-place\" data-place=\"${trimmedPlaceName}\">${placeName}</span>`;\r\n    } else {\r\n      return placeName;\r\n    }\r\n  });\r\n};\r\n\r\nconst formatItineraryToHtml = (rawText, foundPlaces = []) => {\r\n  if (!rawText) return \"\";\r\n  const normalized = rawText.replace(/\\r\\n/g, \"\\n\");\r\n  const lines = normalized\r\n    .split(\"\\n\")\r\n    .map((l) => l.replace(/^\\s*###\\s*/i, \"\").trim());\r\n\r\n  const daySections = [];\r\n  let current = null;\r\n  const dayHeaderRegex = /^#*\\s*day\\s*(\\d+)(?::|-)?\\s*(.*)$/i;\r\n\r\n  const pushCurrent = () => {\r\n    if (current) {\r\n      current.items = current.items.filter((i) => i.trim().length > 0);\r\n      daySections.push(current);\r\n      current = null;\r\n    }\r\n  };\r\n\r\n  const foundLower = foundPlaces.map((p) => p.toLowerCase());\r\n  const foundMap = {};\r\n  foundPlaces.forEach((p) => (foundMap[p.toLowerCase()] = p));\r\n\r\n  for (let rawLine of lines) {\r\n    if (!rawLine) continue;\r\n    let line = rawLine.replace(/^[-*‚Ä¢]\\s*/, \"\").trim();\r\n    if (!line) continue;\r\n    const m = line.match(dayHeaderRegex);\r\n    if (m) {\r\n      pushCurrent();\r\n      const dayNum = m[1];\r\n      const rest = (m[2] || \"\").trim();\r\n      current = {\r\n        title: `Day ${dayNum}${rest ? `: ${rest}` : \"\"}`,\r\n        items: [],\r\n      };\r\n      continue;\r\n    }\r\n    if (!current) continue;\r\n    let cleaned = line.replace(/^[-*‚Ä¢]\\s*/, \"\");\r\n    const dashIdx = cleaned.indexOf(\" - \");\r\n    let itemHtml = cleaned;\r\n    const wrapPlace = (placeLabel) => {\r\n      const original = foundMap[placeLabel.toLowerCase()] || placeLabel;\r\n      return `<span class=\\\"place-name clickable-place blue-place\\\" data-place=\\\"${original}\\\">${original}</span>`;\r\n    };\r\n\r\n    if (dashIdx > 0) {\r\n      let left = cleaned.substring(0, dashIdx).trim();\r\n      let rest = cleaned.substring(dashIdx + 3);\r\n\r\n      left = left.replace(/^[0-9]+\\.\\s*/, \"\").replace(/^[-*‚Ä¢]\\s*/, \"\");\r\n      const leftUnmarked = left.replace(/^\\*\\*(.*)\\*\\*$/, \"$1\").trim();\r\n\r\n      let matched = null;\r\n      if (foundLower.includes(leftUnmarked.toLowerCase())) {\r\n        matched = foundMap[leftUnmarked.toLowerCase()];\r\n      } else {\r\n        for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\r\n          if (leftUnmarked.toLowerCase().includes(p.toLowerCase())) {\r\n            matched = p;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (matched) {\r\n        const wrapped = wrapPlace(matched);\r\n        itemHtml = `${wrapped} - ${rest}`;\r\n      } else {\r\n        itemHtml = `${left} - ${rest}`;\r\n      }\r\n    } else {\r\n      const prefix = cleaned.substring(0, 60);\r\n      let matched = null;\r\n      for (const p of foundPlaces.sort((a, b) => b.length - a.length)) {\r\n        if (prefix.toLowerCase().includes(p.toLowerCase())) {\r\n          matched = p;\r\n          break;\r\n        }\r\n      }\r\n      if (matched) {\r\n        const wrapped = wrapPlace(matched);\r\n        itemHtml = cleaned.replace(new RegExp(matched.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'), wrapped);\r\n      }\r\n    }\r\n\r\n    current.items.push(itemHtml);\r\n  }\r\n  pushCurrent();\r\n\r\n  if (daySections.length === 0) {\r\n    return normalized\r\n      .split(\"\\n\")\r\n      .filter((l) => l.trim().length > 0)\r\n      .map((l) => l.replace(/^\\s*###\\s*/i, \"\"))\r\n      .join(\"<br/>\");\r\n  }\r\n\r\n  const html = daySections\r\n    .map((d) => {\r\n      const itemsHtml = d.items.join(\"<br/>\");\r\n      return `<p style=\\\"margin: 0 0 14px 0;\\\"><strong>${d.title}</strong><br/>${itemsHtml}</p>`;\r\n    })\r\n    .join(\"\\n\");\r\n  return html;\r\n};\r\n\r\nconst geocodePlaces = async (placeNames, placeDescriptions = {}, destCoords = null, setPlaceMarkers, markerRefs) => {\r\n  console.log(\"=== GEOCODING PLACES ===\");\r\n  console.log(\"Place names:\", placeNames);\r\n  console.log(\"Destination coords:\", destCoords);\r\n\r\n  if (!destCoords) {\r\n    console.error(\"‚ùå CRITICAL: No destination coordinates provided - cannot filter places!\");\r\n    return [];\r\n  }\r\n\r\n  const newMarkers = [];\r\n  const foundPlaces = [];\r\n\r\n  const geocodeSinglePlace = async (placeName) => {\r\n    try {\r\n      const city = destCoords.cityName || \"\";\r\n\r\n      console.log(`\\nüîç Geocoding: \"${placeName}\"`);\r\n\r\n      const searchQueries = [];\r\n      if (placeName.toLowerCase().includes(\"museum\")) {\r\n        const nameWithoutMuseum = placeName.replace(/museum/gi, \"\").trim();\r\n        searchQueries.push(`${nameWithoutMuseum} ${city}`);\r\n        searchQueries.push(`${nameWithoutMuseum} Anyk≈°ƒçiai`);\r\n        searchQueries.push(`museum ${city}`);\r\n      }\r\n\r\n      searchQueries.push(`${placeName} ${city}`);\r\n      searchQueries.push(`${placeName} Anyk≈°ƒçiai`);\r\n      searchQueries.push(placeName);\r\n\r\n      const lowerName = placeName.toLowerCase();\r\n      if (lowerName.includes(\"church\") || lowerName.includes(\"matthew\")) {\r\n        searchQueries.push(`church ${city}`);\r\n        searchQueries.push(`ba≈ænyƒçia Anyk≈°ƒçiai`);\r\n      }\r\n\r\n      const calculateDistance = (lat1, lon1, lat2, lon2) => {\r\n        const R = 6371;\r\n        const dLat = (lat2 - lat1) * Math.PI / 180;\r\n        const dLon = (lon2 - lon1) * Math.PI / 180;\r\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\r\n          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\r\n          Math.sin(dLon / 2) * Math.sin(dLon / 2);\r\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n        return R * c;\r\n      };\r\n\r\n      let found = false;\r\n      for (const query of searchQueries) {\r\n        console.log(`   Trying: \"${query}\"`);\r\n\r\n        const response = await fetch(\r\n          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=15&addressdetails=1`\r\n        );\r\n        const data = await response.json();\r\n\r\n        if (data && data.length > 0) {\r\n          console.log(`   ‚Üí Got ${data.length} results`);\r\n\r\n          const resultsWithDistance = data.map(item => {\r\n            const dist = calculateDistance(\r\n              destCoords[0], destCoords[1],\r\n              parseFloat(item.lat), parseFloat(item.lon)\r\n            );\r\n            return { ...item, distance: dist };\r\n          });\r\n\r\n          const nearbyResults = resultsWithDistance.filter(item => item.distance <= 50);\r\n\r\n          if (nearbyResults.length === 0) {\r\n            console.log(`   ‚ùå No results within 50km`);\r\n            continue;\r\n          }\r\n\r\n          nearbyResults.sort((a, b) => a.distance - b.distance);\r\n\r\n          const bestMatch = nearbyResults[0];\r\n          const { lat, lon, display_name, distance } = bestMatch;\r\n          const coordinates = [parseFloat(lat), parseFloat(lon)];\r\n\r\n          console.log(`   ‚úÖ FOUND: ${display_name.substring(0, 70)}`);\r\n          console.log(`      Distance: ${distance.toFixed(1)}km`);\r\n\r\n          newMarkers.push({\r\n            position: coordinates,\r\n            popup: `${placeName}<br><small>${display_name}</small>`,\r\n            type: \"place\",\r\n            placeName: placeName,\r\n            fullAddress: display_name,\r\n            aiDescription: placeDescriptions[placeName] || null,\r\n          });\r\n          foundPlaces.push(placeName);\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!found) {\r\n        console.log(`   ‚ùå NOT FOUND: \"${placeName}\"`);\r\n      }\r\n    } catch (error) {\r\n      console.error(`   ‚ùå ERROR: ${placeName}:`, error);\r\n    }\r\n  };\r\n\r\n  const concurrency = 3;\r\n  let idx = 0;\r\n  async function runBatch() {\r\n    const batch = [];\r\n    for (let i = 0; i < concurrency && idx < placeNames.length; i++, idx++) {\r\n      batch.push(geocodeSinglePlace(placeNames[idx]));\r\n    }\r\n    await Promise.all(batch);\r\n    if (idx < placeNames.length) {\r\n      await new Promise((resolve) => setTimeout(resolve, 300));\r\n      return runBatch();\r\n    }\r\n  }\r\n  await runBatch();\r\n\r\n  if (newMarkers.length > 0) {\r\n    setPlaceMarkers((prev) => {\r\n      const allMarkers = [...prev, ...newMarkers];\r\n      const seen = new Set();\r\n      return allMarkers.filter(m => {\r\n        if (seen.has(m.placeName)) return false;\r\n        seen.add(m.placeName);\r\n        return true;\r\n      });\r\n    });\r\n    console.log(`\\n‚úÖ Added ${newMarkers.length} markers to map`);\r\n  } else {\r\n    console.log(\"\\n‚ùå No markers were added\");\r\n  }\r\n\r\n  const notFoundPlaces = placeNames.filter((name) => !foundPlaces.includes(name));\r\n  if (notFoundPlaces.length > 0) {\r\n    console.log(`‚ö†Ô∏è Not found: ${notFoundPlaces.join(\", \")}`);\r\n  }\r\n\r\n  return foundPlaces;\r\n};\r\n\r\nconst geocodeDestination = async (destinationName) => {\r\n  try {\r\n    console.log(\"Geocoding destination:\", destinationName);\r\n    const response = await fetch(\r\n      `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(\r\n        destinationName\r\n      )}&limit=1`\r\n    );\r\n    const data = await response.json();\r\n    console.log(\"Geocoding response:\", data);\r\n\r\n    if (data && data.length > 0) {\r\n      const { lat, lon } = data[0];\r\n      const coordinates = [parseFloat(lat), parseFloat(lon)];\r\n      console.log(\"Found coordinates:\", coordinates);\r\n\r\n      return coordinates;\r\n    } else {\r\n      console.log(\"No results found for:\", destinationName);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Geocoding error:\", error);\r\n  }\r\n  return null;\r\n};\r\n\r\nfunction Chat({ destination, days, onBackToWelcome }) {\r\n  const [messages, setMessages] = useState([]);\r\n  const [inputMessage, setInputMessage] = useState(\"\");\r\n  const [mapCenter, setMapCenter] = useState([51.505, -0.09]);\r\n  const [destinationMarker, setDestinationMarker] = useState(null);\r\n  const [placeMarkers, setPlaceMarkers] = useState([]);\r\n  const markerRefs = useRef({});\r\n  const messagesEndRef = React.useRef(null);\r\n  const itineraryRunRef = React.useRef(\"\");\r\n\r\n  const scrollToBottom = () => {\r\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\r\n  };\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      if (!destination || !days) return;\r\n      const runKey = `${String(destination).trim().toLowerCase()}|${String(\r\n        days\r\n      ).trim()}`;\r\n      if (itineraryRunRef.current === runKey) {\r\n        console.log(\"‚è≠Ô∏è Skipping duplicate itinerary generation for\", runKey);\r\n        return;\r\n      }\r\n      itineraryRunRef.current = runKey;\r\n\r\n      try {\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: \"Generating your itinerary...I'm slow because I'm free! üê¢üê¢üê¢\",\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n            isLoading: true,\r\n          },\r\n        ]);\r\n\r\n        console.log(\"üî∞ Starting itinerary generation for\", destination, days);\r\n\r\n        const destCoords = await geocodeDestination(destination);\r\n\r\n        if (!destCoords) {\r\n          throw new Error(\"Could not geocode destination\");\r\n        }\r\n\r\n        setMapCenter(destCoords);\r\n\r\n        setDestinationMarker({\r\n          position: destCoords,\r\n          popup: `${destination} - Your destination for ${days} days`,\r\n          type: \"destination\",\r\n          placeName: destination,\r\n          fullAddress: `${destination}, ${destination}`,\r\n        });\r\n\r\n        const itineraryPrompt = `Create a concise, practical ${days}-day travel itinerary for ${destination}.\r\n\r\nCRITICAL REQUIREMENTS:\r\n- ONLY include major, well-known attractions, landmarks, and establishments\r\n- Use simple, commonly-known names (e.g., \"Old Town\" not \"Historic Old Quarter\")\r\n- Avoid specific restaurant/cafe/bar names unless they're very famous\r\n- Focus on parks, churches, museums, main squares, rivers, etc.\r\n- For every place, wrap the name in **double asterisks**\r\n- Provide 3-6 items per day with short descriptions\r\n\r\nExample format:\r\n**Main Cathedral** - Description\r\n**City Park** - Description\r\n**Old Town Square** - Description\r\n`;\r\n\r\n        const response = await fetch(`${API_URL}/api/chat`, {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({ message: itineraryPrompt }),\r\n        });\r\n\r\n        if (!response.ok) throw new Error(`HTTP error ${response.status}`);\r\n        const data = await response.json();\r\n\r\n        const placeNames = extractPlaceNames(data.message);\r\n        const placeDescriptions = extractPlaceDescriptions(data.message, placeNames);\r\n\r\n        let foundPlaces = [];\r\n        if (placeNames.length > 0) {\r\n          foundPlaces = await geocodePlaces(placeNames, placeDescriptions, destCoords, setPlaceMarkers, markerRefs);\r\n        }\r\n\r\n        const welcomeMessage = {\r\n          id: 1,\r\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          isWelcome: true,\r\n        };\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: `Here is a suggested ${days}-day itinerary for ${destination}:<br/><br/>${formatItineraryToHtml(\r\n              data.message,\r\n              foundPlaces\r\n            )}`,\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n            foundPlaces,\r\n            isItinerary: true,\r\n          },\r\n          welcomeMessage,\r\n        ]);\r\n      } catch (err) {\r\n        console.error(\"Failed to generate itinerary:\", err);\r\n        const welcomeMessage = {\r\n          id: 1,\r\n          text: `Welcome! I'll help you plan your ${days}-day trip to ${destination}. What would you like to know about your destination?`,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          isWelcome: true,\r\n        };\r\n        setMessages([\r\n          {\r\n            id: 0,\r\n            text: \"Could not generate itinerary automatically. You can ask for suggestions in the chat.\",\r\n            sender: \"ai\",\r\n            timestamp: new Date().toLocaleTimeString(),\r\n          },\r\n          welcomeMessage,\r\n        ]);\r\n      }\r\n    })();\r\n  }, [destination, days]);\r\n\r\n  useEffect(() => {\r\n    scrollToBottom();\r\n\r\n    const handleClick = (e) => {\r\n      const target = e.target;\r\n      if (target.classList.contains(\"clickable-place\")) {\r\n        const placeName = target.getAttribute(\"data-place\");\r\n        const ref = markerRefs.current[placeName];\r\n        if (ref && ref.current && ref.current.openPopup) {\r\n          ref.current.openPopup();\r\n        }\r\n      }\r\n    };\r\n    document.addEventListener(\"click\", handleClick);\r\n    return () => {\r\n      document.removeEventListener(\"click\", handleClick);\r\n    };\r\n  }, [messages, placeMarkers]);\r\n\r\n  const handleSendMessage = async (e) => {\r\n    e.preventDefault();\r\n    if (!inputMessage.trim()) return;\r\n\r\n    const newMessage = {\r\n      id: messages.length + 1,\r\n      text: inputMessage,\r\n      sender: \"user\",\r\n      timestamp: new Date().toLocaleTimeString(),\r\n    };\r\n\r\n    setMessages([...messages, newMessage]);\r\n    const userMessage = inputMessage;\r\n    setInputMessage(\"\");\r\n\r\n    const loadingMessage = {\r\n      id: messages.length + 2,\r\n      text: \"LaWander is thinking...\",\r\n      sender: \"ai\",\r\n      timestamp: new Date().toLocaleTimeString(),\r\n      isLoading: true,\r\n    };\r\n    setMessages((prev) => [...prev, loadingMessage]);\r\n\r\n    try {\r\n      const contextualMessage = `Context: The user is planning a ${days}-day trip to ${destination}. \\n\\nIMPORTANT INSTRUCTIONS:\\n- If the user asks for a specific type of place (restaurants, museums, hotels, etc.), ONLY provide places of that exact type\\n- ALL places must be located in or very near ${destination}\\n- When mentioning places, use the format **PlaceName** for each place\\n- Be specific and accurate about locations - only include places that are actually in ${destination}\\n- For each place you mention, provide a brief description (1-2 sentences) about what makes it special or what it offers\\n- Include practical information like cuisine type, atmosphere, or unique features\\n\\nUser question: ${userMessage}`;\r\n\r\n      const response = await fetch(`${API_URL}/api/chat`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n        },\r\n        body: JSON.stringify({\r\n          message: contextualMessage,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n\r\n      const placeNames = extractPlaceNames(data.message);\r\n      console.log(\"AI Response:\", data.message);\r\n      console.log(\"Extracted place names:\", placeNames);\r\n\r\n      const placeDescriptions = extractPlaceDescriptions(data.message, placeNames);\r\n\r\n      let foundPlaces = [];\r\n      if (placeNames.length > 0) {\r\n        console.log(\"Starting geocoding for\", placeNames.length, \"places\");\r\n        const destCoords = destinationMarker ? destinationMarker.position : null;\r\n        foundPlaces = await geocodePlaces(placeNames, placeDescriptions, destCoords, setPlaceMarkers, markerRefs);\r\n      } else {\r\n        console.log(\"No place names found in AI response\");\r\n      }\r\n\r\n      setMessages((prev) => {\r\n        const withoutLoading = prev.filter((msg) => !msg.isLoading);\r\n        const aiResponse = {\r\n          id: withoutLoading.length + 1,\r\n          text: data.message,\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n          foundPlaces: foundPlaces,\r\n        };\r\n        return [...withoutLoading, aiResponse];\r\n      });\r\n    } catch (error) {\r\n      console.error(\"Error calling chat API:\", error);\r\n\r\n      setMessages((prev) => {\r\n        const withoutLoading = prev.filter((msg) => !msg.isLoading);\r\n        const errorResponse = {\r\n          id: withoutLoading.length + 1,\r\n          text: \"Sorry, I'm having trouble connecting to the server. Please try again later.\",\r\n          sender: \"ai\",\r\n          timestamp: new Date().toLocaleTimeString(),\r\n        };\r\n        return [...withoutLoading, errorResponse];\r\n      });\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"chat-app\">\r\n      <div className=\"chat-header\">\r\n        <div className=\"header-left\">\r\n          <button className=\"back-button\" onClick={onBackToWelcome}>\r\n            ‚Üê Change Trip\r\n          </button>\r\n          <h1 className=\"chat-title\">LaWander</h1>\r\n        </div>\r\n        <div className=\"trip-info\">\r\n          <span className=\"destination\">{destination}</span>\r\n          <span className=\"days\">{days} days</span>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"chat-container\">\r\n        <div className=\"chat-window\">\r\n          <MessageList messages={messages} formatMessageText={formatMessageText} messagesEndRef={messagesEndRef} />\r\n          <MessageForm inputMessage={inputMessage} setInputMessage={setInputMessage} handleSendMessage={handleSendMessage} />\r\n        </div>\r\n\r\n        <MapView mapCenter={mapCenter} destinationMarker={destinationMarker} placeMarkers={placeMarkers} days={days} markerRefs={markerRefs} />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Chat;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}